<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不死De小丑</title>
  
  <subtitle>我很想记得，可是我记不得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dingding15yd.github.io/"/>
  <updated>2020-01-15T03:36:58.258Z</updated>
  <id>https://dingding15yd.github.io/</id>
  
  <author>
    <name>dingding</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git - 命令手册</title>
    <link href="https://dingding15yd.github.io/2020/01/07/Git-%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>https://dingding15yd.github.io/2020/01/07/Git-命令手册/</id>
    <published>2020-01-07T01:19:23.000Z</published>
    <updated>2020-01-15T03:36:58.258Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git-配置相关"><a href="#Git-配置相关" class="headerlink" title="Git 配置相关"></a>Git 配置相关</h3><p>如果你首次使用Git，那刚开始首先是需要配置各种身份信息的，这样当你提交相关任务的时候，别人或者Github等才能识别这个 commit  的提交者身份和权限。</p><h5 id="一、Git最小配置"><a href="#一、Git最小配置" class="headerlink" title="一、Git最小配置"></a>一、Git最小配置</h5><ol><li>配置全局账户，也就是该账户对所有的Git仓库都有效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &apos;你的账户名称&apos;</span><br><span class="line">git config --global user.eamil &apos;你的邮箱地址&apos;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置局部账户，也就是该账户只对当前 Git 仓库有效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &apos;你的账户名称&apos;</span><br><span class="line">git config --local user.email &apos;你的邮箱地址&apos;</span><br></pre></td></tr></table></figure><p>​    注意，不同点就是一个参数是 global（全局），一个是local（本地）</p><h5 id="二、查看相关配置情况"><a href="#二、查看相关配置情况" class="headerlink" title="二、查看相关配置情况"></a>二、查看相关配置情况</h5><p>​    有的时候我们需要查看我们当前配置的相关情况的，可以使用如下命令</p><pre><code>1. 查看global类型的配置情况</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><pre><code>2. 查看某个仓库下的配置情况</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br></pre></td></tr></table></figure><p><img src="/2020/01/07/Git-命令手册/更多基本操作.png" alt></p><h3 id="本地基本操作"><a href="#本地基本操作" class="headerlink" title="本地基本操作"></a>本地基本操作</h3><p>​    这部分命令有点多，也是使用的最频繁的命令了。</p><h5 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h5><p>​    1、查看变更情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>​    2、查看当前工作在哪个分支上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><p>​    3、切换到指定分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 指定分支的名称</span><br></pre></td></tr></table></figure><p>​    4、把<font color="orange">当前目录及其子目录</font>下所有变更都加入到<font color="orange">暂存区</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .           //注意，add后面是一个‘.’</span><br></pre></td></tr></table></figure><p>​    5、把仓库内<font color="orange">所有</font>变更都加入到暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure><p>​    6、把指定文件添加到暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 文件1 文件2 ... 文件n</span><br></pre></td></tr></table></figure><p>​    7、创建正式的commit，也就是把当前的数据提交上去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><h5 id="二、比较差异"><a href="#二、比较差异" class="headerlink" title="二、比较差异"></a>二、比较差异</h5><p>​    1、比较某文件工作区和暂存区的差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 某文件</span><br></pre></td></tr></table></figure><p>​    2、比较某文件暂存区和 HEAD 的差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cache 某文件</span><br></pre></td></tr></table></figure><p>​    3、比较工作区和暂存区的所有差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>​    4、比较暂存区和 HEAD 的所有差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cache</span><br></pre></td></tr></table></figure><h5 id="三、暂存区与工作区之间回滚"><a href="#三、暂存区与工作区之间回滚" class="headerlink" title="三、暂存区与工作区之间回滚"></a>三、暂存区与工作区之间回滚</h5><p>​    1、把工作区指定文件恢复成和暂存区一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 文件1 文件2 ... 文件n</span><br></pre></td></tr></table></figure><p>​    2、把暂存区指定文件恢复成和 HEAD 一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset 文件1 文件2 ... 文件n</span><br></pre></td></tr></table></figure><p>​    3、把暂存区和工作区所有文件恢复成和 HEAD 一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure><p>​    4、用 difftool 比较任意两个 commit 的差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git difftool commit1 commit2</span><br></pre></td></tr></table></figure><p>​    <font color="red">注意，从工作区回滚到暂存区则用checkout，否则用reset </font></p><h5 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h5><p>​    查看哪些文件没有被 Git 管控</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --others</span><br></pre></td></tr></table></figure><h3 id="加塞临时任务处理"><a href="#加塞临时任务处理" class="headerlink" title="加塞临时任务处理"></a>加塞临时任务处理</h3><p>​    1、把未完成的变更先保存到 stash 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>​    2、临时任务处理完成后继续之前的工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash pop                    //pop 相当于栈的出栈和入栈一样，把之前的任务弹出来</span><br><span class="line">或者</span><br><span class="line">git stash apply                 //和 pop 不同的是，apply相当于从栈顶把任务取出来，但是不会从栈中把任  务移除</span><br></pre></td></tr></table></figure><p>​    3、查看所有的stash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>​    4、取回某次的 stash 的变更</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash @&#123;数字n&#125;</span><br></pre></td></tr></table></figure><h3 id="修改个人分支历史"><a href="#修改个人分支历史" class="headerlink" title="修改个人分支历史"></a>修改个人分支历史</h3><p>​    我们的仓库的内容每次变更执行 commit 的时候，都会生成一个新的 commit ，不过有时候我们不想产生新的 commit，而是想要通过修改之前的 commit 来变更仓库的内容，那么就可以使用如下命令了。</p><p>​    1、修改最后一次 commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在工作区中修改文件</span><br><span class="line">2.git add</span><br><span class="line">3.git commit --amend</span><br></pre></td></tr></table></figure><p>​    2、修改中间的 commit (假设代号为 x)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.git rebase -i  x前面的一个commit的id</span><br><span class="line">2.在工作区修改文件</span><br><span class="line">3.git add</span><br><span class="line">4.git rebase --contiue</span><br></pre></td></tr></table></figure><p>还没彻底搞懂 Git Rebase，点击这里 <a href="https://www.codercto.com/a/45325.html" target="_blank" rel="noopener">https://www.codercto.com/a/45325.html</a></p><h3 id="查看变更日记等"><a href="#查看变更日记等" class="headerlink" title="查看变更日记等"></a>查看变更日记等</h3><p>​    1、当前分支各个commit用一行显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --online</span><br></pre></td></tr></table></figure><p>​    2、显示最近的n个commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -n</span><br></pre></td></tr></table></figure><p>​    3、用图示显示所有的分支历史</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --online -graph --all</span><br></pre></td></tr></table></figure><p>​    4、查看涉及到某文件变更的所有commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log 某文件</span><br></pre></td></tr></table></figure><p>​    5、某文件各行最后修改对应的commit以及作者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame 某文件</span><br></pre></td></tr></table></figure><h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><h5 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h5><p>​    1、基于当前分支创建新分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支名</span><br></pre></td></tr></table></figure><p>​    2、基于指定分支创建新分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支 已有分支</span><br></pre></td></tr></table></figure><p>​    3、基于某个commit创建分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支 某个commit的id</span><br></pre></td></tr></table></figure><p>​    4、创建分支并且切换到该分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 新分支</span><br></pre></td></tr></table></figure><h5 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h5><p>​    1、列出本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><p>​    2、列出本地和远端分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p>​    3、列出远端所有分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -rv</span><br></pre></td></tr></table></figure><p>​    4、列出名称符号某样式的远端分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -rv -l &apos;某样式&apos;</span><br></pre></td></tr></table></figure><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><p>​    1、安全删除本地某分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 要删除的分支</span><br></pre></td></tr></table></figure><p>​    2、强行删除本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D 要删除的分支</span><br></pre></td></tr></table></figure><p>​    3、删除已合并到master分支的所有本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged master | grep -v &apos;^\*\|master&apos; | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure><p>​    4、删除远端origin已不存在的所有本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure><p>​    </p><h5 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h5><p>​    1、从commit打上标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签名 commit的id</span><br></pre></td></tr></table></figure><h3 id="两分支之间的集成"><a href="#两分支之间的集成" class="headerlink" title="两分支之间的集成"></a>两分支之间的集成</h3><p>​    1、把A分支合入到当前分支，且为merge创建commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge A分支</span><br></pre></td></tr></table></figure><p>​    2、把A分支合入到B分支，且为Merge创建commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge A分支 B分支</span><br></pre></td></tr></table></figure><p>​    3、把当前分支基于B分支做rebase，以便把B分支合入到当前分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase B分支</span><br></pre></td></tr></table></figure><p>​    4、把A分支基于B分支做rebase，以便把B分支合入到A分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase B分支 A分支</span><br></pre></td></tr></table></figure><p>​    5、用mergetool解决冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mergetool</span><br></pre></td></tr></table></figure><h3 id="和远端交互"><a href="#和远端交互" class="headerlink" title="和远端交互"></a>和远端交互</h3><p>​    1、列出所有remote</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>​    2、增加remote</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add url地址</span><br></pre></td></tr></table></figure><p>​    3、删除remote</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove remote的名称</span><br></pre></td></tr></table></figure><p>​    4、改变remote 的 name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename 旧名称 新名称</span><br></pre></td></tr></table></figure><p>​    5、把远端所有分支和标签的变更都拉到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch remote</span><br></pre></td></tr></table></figure><p>​    6、把远端分支的变更拉到本地，且merge到本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull remote名称 分支名</span><br></pre></td></tr></table></figure><p>关于pull和fetch的区别不懂的可以看这篇文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486636&amp;idx=2&amp;sn=b3d94e89b4bf2e7dba8b995dc694ccd8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">从0学习Git：详解git pull和git fetch的区别</a> </p><p>​    </p><p>​    7、把本地分支push到远端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push remote名称 分支名</span><br></pre></td></tr></table></figure><p>​    8、删除远端分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push remote --delete 远端分支名</span><br><span class="line">或者</span><br><span class="line">git push remote：远端分支名</span><br></pre></td></tr></table></figure><p>​    9、向远端提交指定标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push remote 标签名</span><br></pre></td></tr></table></figure><p>​    10、向远端提交所有标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push remote --tags</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    如果只是会这些命令是不太行的，还需要再深入了解其中的原理。</p>]]></content>
    
    <summary type="html">
    
      将所有GIT命令都分类总结了一下，方便日后查找。
    
    </summary>
    
      <category term="沧海拾遗" scheme="https://dingding15yd.github.io/categories/%E6%B2%A7%E6%B5%B7%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="java" scheme="https://dingding15yd.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>彻底弄懂UTF-8 和 GBK</title>
    <link href="https://dingding15yd.github.io/2019/12/31/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82UTF-8-%E5%92%8C-GBK/"/>
    <id>https://dingding15yd.github.io/2019/12/31/彻底弄懂UTF-8-和-GBK/</id>
    <published>2019-12-31T04:44:26.000Z</published>
    <updated>2020-01-15T03:36:58.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="彻底搞懂编码-GBK-和-UTF-8"><a href="#彻底搞懂编码-GBK-和-UTF-8" class="headerlink" title="彻底搞懂编码 GBK 和 UTF-8"></a>彻底搞懂编码 GBK 和 UTF-8</h1><h3 id="常用编码格式一览"><a href="#常用编码格式一览" class="headerlink" title="常用编码格式一览"></a>常用编码格式一览</h3><p><img src="/2019/12/31/彻底弄懂UTF-8-和-GBK/1.png" alt></p><p>​    首先来看一下常用的编码有哪些，图来自Notepad++。其中ANSI在中国大陆即为BGK（以前是GB2312），最常用的是 <font color="green">GBK</font> 和 <font color="green">UTF无BOM</font> 编码格式。后面三个都是有BOM头的文本格式，UCS-2即为人们常说的Unicode编码，又分为大端、小端。</p><p>​    所谓BOM头(Byte Order Mark)就是文本文件开始的几个并不表示任何字符的字节，用二进制编辑器（如bz.exe）就能看到了。</p><ol><li><p>UTF-8的BOM头为 0xEF 0xBB 0xBF</p></li><li><p>Unicode大端模式为0xFE 0xFF</p></li><li><p>Unicode小端模式为0xEF 0xFE</p><p><img src="/2019/12/31/彻底弄懂UTF-8-和-GBK/2.jpg" alt></p></li></ol><h3 id="何为GBK，何为GB2312-，与区位码有何渊源？"><a href="#何为GBK，何为GB2312-，与区位码有何渊源？" class="headerlink" title="何为GBK，何为GB2312,，与区位码有何渊源？"></a>何为GBK，何为GB2312,，与区位码有何渊源？</h3><p>​    区位码是早年(1980)中国制定的一个编码标准，如果有玩过小霸王学习机的话，应该会记得有个叫做“区位”的输入法（没记错的话是按F4选择）。就是打四个数字就出来汉字了，什么原理呢。请看下面的区位码表，每一个字符都有一个对应的编号。其中前两位为“区”，后两位为“位”，中文汉字的编号区号是从16开始的，位号从1开始。前面的区号有一些符号、数字、字母、注音字符（台）、制表符、日文等等。</p><p>​    而BG2312编码就是基于区位码的，用双字节编码表示中文和中文符号。一般编码方式是：<font color="green">0xA0+区号，0xA0+位号</font>。如下表中的“安”，区位号是1618（十进制），那么“安”字的GB2312编码就是0xA0+16 0xA0+18也就是0xB0 0xB2。根据区位码表，GB2312的汉字编码范围是0xB0A1~0xF7FE</p><p> <a href="http://www.xuebuyuan.com/879025.html" target="_blank" rel="noopener">区位码表节选</a> </p><p><img src="/2019/12/31/彻底弄懂UTF-8-和-GBK/3.jpg" alt></p><p><img src="/2019/12/31/彻底弄懂UTF-8-和-GBK/4.jpg" alt></p><p>​    可能大家注意到了，区位码里有英文和数字，按道理说是不是也应该是双字节的呢。而一般情况下，我们见到的英文和数字是的单字节的，以ASCII编码，也就是说现代的GBK编码是兼容ASCII编码的。比如一个数字2，对应的二进制是0x32，而不是0xA3 0xB2。那么问题来了，0xA3 和 0xB2又对应什么呢？还是 ２ (笑)。注意看了，这里的 ２ 跟2是不是有点不太一样？！确实是不一样的。这里的<font color="green">双字节 ２ 是全角的二，ASCII的2是半角的二，</font>一般输入法里面的切换全角半角就是这里不同。</p><p>​    如果留意过早些年的手机（功能机），会发现人名中常见的“燊”字是打不出来的。为什么呢？因为早期的区位码表里面并没有这些字，也就是说早期的GB2312也是没有这些字的。到后来的GBK（1995）才补充了大量的汉字进去，当然现在的安卓苹果手机应该都是BGK字库了。再看看这些补充的汉字的字节码<font color="green">燊 0x9F 0xF6</font>。和前面说到的GB2312不同，有的字的编码比0xA0 0xA0还小，难道新补充的区位号还能是负的？其实不然，这次的补充只补充了计算机编码表，并没有补充区位编码表。也就是说区位码表并没有更新，用区位码打字法还是打不出这些字，而网上的反向区位码表查询也只是按照GBK的编码计算，并不代表子与区位号完全对应。时代的发展，区位码表早已经是进入博物馆的东西了。</p><p>​    Big5是与B2312同时期的一种台湾地区繁体字的编码格式。后来GBK编码的制定，把Big5用的繁体字也包含进来（但编码不兼容），还增加了一些其他的中文字符。细心的朋友可能还会发现，台湾香港用的繁体字（如ktv里的字幕）跟大陆用的繁体字还有点笔画上不一样，其实这跟编码无关，是字体的不同，大陆一般用的是宋体楷体黑体，港澳台常用的是明体（ <a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥Linux私房菜</a> 用的是新细明体）。GBK总体编码范围为0x8140~0xFEFE，首字节在0x81~0xFE之间，尾字节在0x40~0xFE之间，剔除xx7F一条线。详细编码表可以 <a href="http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php" target="_blank" rel="noopener">参考这个列表</a> 。微软Windows安排给GBK的code page（代码页）是CP936，所以有的时候看到编码格式是CP936，其实就是GBK的意思。2000年和2005年，国家又先后发布了GB18030编码标准，兼容GBK，新增四字节的编码，但比较少见。</p><p>​    同一个编码文件里，怎么区分ASCII和中文编码呢？从 <a href="http://www.asciitable.com/" target="_blank" rel="noopener">ASCII表</a> 我们知道标准ASCII只有128个字符，0~127即0x00~0x7F（0111 1111）.所以区分的方法就是，高字节的最高位为0则为ASCII，为1则为中文。</p><h3 id="UTF8编码与Unicode编码"><a href="#UTF8编码与Unicode编码" class="headerlink" title="UTF8编码与Unicode编码"></a>UTF8编码与Unicode编码</h3><p>​     GBK是中国标准，只在中国使用，并没有表示大多数其它国家的编码；而各国又陆续推出各自的编码标准，互不兼容，非常不利于全球化发展。于是后来国际组织发行了一个全球统一编码表，把全球各国文字都统一在一个编码标准里，名为Unicode。很多人都很疑惑，到底UTF8与Unicode两者有什么关系？如果要类比的话，UTF8相当于GB2312，Unicode相当于区位码表，不同的是它们之间的编号范围和转换公式。那什么是原始的Unicode编码呢？如果你用过PHP的话，json_encode函数默认会把中文编码成为Unicode，比如“<font color="green">首发于博客园</font>”就会转码成“<font color="green">\u9996\u53d1\u4e8e\u535a\u5ba2\u56ed</font>”。可以看到每个字都变成了 <strong>\uXXXX</strong> 的形式，这个就是文字的对应Unicode编码，\u表示Unicode的意思，网上也有用U+表示unicode。现行的Unicode编码标准里，绝大多数程序语言只支持<strong>双字节</strong>。英文字母、标点也收纳在Unicode编码中。有兴趣的可以在<a href="http://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="noopener">站长工具</a>里尝试“中文转Unicode”，可以得到你输入文字的Unicode编码。 </p><p>​     因为英文字符也全部使用双字节，存储成本和流量会大大地增加，所以Unicode编码大多数情况并没有被原始地使用，而是被转换编码成UTF8。下表就是其转换公式： </p><p><img src="/2019/12/31/彻底弄懂UTF-8-和-GBK/5.png" alt></p><p>​     第一种：Unicode从 0x0000 到 0x007F 范围的，是不是有点熟悉？对，其实就是标准ASCII码里面的内容，所以直接去掉前面那个字节 0x00，使用其第二个字节（与ASCII码相同）作为其编码，即为单字节UTF8。 </p><p>​     第二种：Unicode从 0x0080 到 0x07FF 范围的，转换成双字节UTF8。 </p><p>​     第三种：Unicode从 0x8000 到 0xFFFF 范围的，转换成<font color="green">三字节UTF8，一般中文</font>都是在这个范围里。 </p><p>​     第四种：超过双字节的Unicode目前还没有广泛支持，仅见<font color="green">emoji表情</font>在此范围。 </p><p>​     例如“博”字的Unicode编码是\u535a。0x535A在0x0800~0xFFFF之间，所以用3字节模板 1110yyyy 10yyyyxx 10xxxxxx。将535A写成二进制是：0101 0011 0101 1010，高八位分别代替y，低八位分别代替x，得到 11100101 10001101 10011010，也就是 0xE58D9A ，这就是博字的UTF8编码。 </p><p>​     前面提到，GBK的编码里英文字符有全角和半角之分，全角为GBK的标准编码过的双字节２，半角为ASCII的单字节2。那现在UTF8是全部用一个公式，理论上只有半角的2的，怎么支持全角的２呢？哈哈，结果是Unicode为中国特色的<font color="green">全角英文字符也单独分配了编码</font>，简单粗暴。比如全角的２的Unicode编码是 \uFF12，转换到UTF8就是 0xEFBC92。 </p><p>​     文章开头有说到 UCS-2，其实UCS-2就是原始的双字节Unicode编码，用二进制编辑器打开UCS-2大端模式的文本文件，从左往右看，看到的就是每个字符的Unicode编码了。至于什么是大端小端，就是字节的存放顺序不同，这一般是嵌入式编程的范畴。 </p><h3 id="如何区分一个文本是无BOM的UTF8还是GBK"><a href="#如何区分一个文本是无BOM的UTF8还是GBK" class="headerlink" title="如何区分一个文本是无BOM的UTF8还是GBK"></a>如何区分一个文本是无BOM的UTF8还是GBK</h3><p>​     前面说到的几种编码，其中有的是有BOM头的，可以直接根据BOM头区分出其编码。有两个是没有BOM头的，UTF8和GBK，那么两者怎么区分呢？答案是，只能按大量的编码分析来区分。目前识别准确率很高的有：Notepad++等一些常用的IDE，PHP的mb_系列函数，python的chardet库及其它语言衍生版如jchardet，<a href="https://github.com/aadsm/jschardet" target="_blank" rel="noopener">jschardet </a>等（请自行github）。 </p><p>​     那么这些库是怎么区分这些编码的呢？那就是词库，你会看到库的源码里有大量的数组，其实就是对应一个编码里的常见词组编码组合。同样的文件字节流在一个词组库里的匹配程度越高，就越有可能是该编码，判断的准确率就越大。而文件中的中文越少越零散，判断的准确率就越低。 </p><h3 id="关于ASCII"><a href="#关于ASCII" class="headerlink" title="关于ASCII"></a>关于ASCII</h3><p>​     文中多次提及ASCII编码，其实这应该是每个程序员都非常熟悉、认真了解的东西。对于嵌入式开发的人来说，应该能随时在字符与ASCII码中转换，就像十六进制与二进制之间的转换一样。标准ASCII是128个，范围是0x00~0x7F (0000 0000~0111 0000) ，最高位为0。也有一个扩展ASCII码规则，把最高位也用上了，变成256个，但是这个扩展标准争议很大，没有得到推广，应该以后不会得到推广。因为无论是GBK还是UTF8，如果ASCII字符编码最高位能为1都会造成混乱无法解析。 </p><p>​     以GBK为例，如果ASCII的字符最高位也能是1，那么是应该截取一个解析为ASCII呢？还是截取两个解析为中文字符？这根本无法判断。UTF8也是同理，遇到 0xxx 开头则截取一个（即为标准ASCII）， 遇到 110x 开头则截取两个，遇到 1110 开头则截取三个，如果ASCII包含1开头的，则无法确定何时截取多少个。 </p><p>​     在哪里还能一睹扩展ASCII的真容呢？其实很简单，只要把网页的meta改成ASCII就行了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=&quot;ASCII&quot;/&gt;</span><br></pre></td></tr></table></figure><p> 又或者浏览器的编码选择“西方”，即可见到与平常所见不同的乱码。（截图为火狐） </p><p><img src="/2019/12/31/彻底弄懂UTF-8-和-GBK/6.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      GBK、GB2312 、  GB18030 、  Unicode 、 UTF8 之间的关联。
    
    </summary>
    
      <category term="沧海拾遗" scheme="https://dingding15yd.github.io/categories/%E6%B2%A7%E6%B5%B7%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="java" scheme="https://dingding15yd.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>中文全角和半角的缘由？</title>
    <link href="https://dingding15yd.github.io/2019/12/30/%E4%B8%AD%E6%96%87%E5%85%A8%E8%A7%92%E5%92%8C%E5%8D%8A%E8%A7%92%E7%9A%84%E7%BC%98%E7%94%B1%EF%BC%9F/"/>
    <id>https://dingding15yd.github.io/2019/12/30/中文全角和半角的缘由？/</id>
    <published>2019-12-30T04:33:44.000Z</published>
    <updated>2020-01-15T03:36:58.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中文全角和半角的区别"><a href="#中文全角和半角的区别" class="headerlink" title="中文全角和半角的区别"></a>中文全角和半角的区别</h1><p><strong>符号冲突是主要原因</strong></p><p>​    有些数字或符号是有冲突的，比如英文逗号,与中文逗号，用眼睛就可以看出长度与大小是不一样的。当在键盘上输入逗号时，中文输入法不确定你想要的是哪种逗号(中/英)，所以就提供了全角半角模式，英文半角输入英文逗号，其他模式就是中文逗号，这样，我们用一种输入法就能打出两种符号，而不用切换成其他输入法。</p><p>​    更细致的原因要从以下各点说起：</p><p><strong>1.二进制</strong></p><p>​    计算机普遍遵循冯诺依曼结构体系，它规定了计算机内部以二进制为主要数制(这和电路有关)，所以计算机只认识二进制的0或1.其他符号比如十进制的[2-9]，字母[a-zA-Z]，标点符号，中文等等是不认识的，那么，当我们说’a’的时候，它是怎么理解的呢？</p><p><strong>2.编码表</strong></p><p>​    既然计算机只认识01符号，那我们就可以建立一套“映射系统”，比如：</p><p>​    a &lt; – &gt; 00000001</p><p>​    b &lt; – &gt; 00000010</p><p>​    c &lt; – &gt; 00000011</p><p>​    当我们说“a”的时候，计算机就理解为“00000001”，即一个符号，用一串唯一的二进制表示，这套‘映射系统’就称为编码表。</p><p><strong>3.ASCII编码表</strong></p><p>​    因为早期的计算机只在发达的欧美国家使用，所以这套“映射系统”是根据英文系统规则设计的，叫ASCII表，规定用8位长度的二进制表示，最多可以表示 2^8 = 256 个字符。ASCII表涵盖了英文字母，数字，和常用的英文符号，比如“,.+-”等。</p><p>​    可普通汉字就有6万多个，很明显8位的ASCII编码方案满足不了中文系统的要求，比如中文“啊”，就无法用ASCII表示。</p><p><strong>4.中文编码表</strong></p><p>​    由上我们知道，只要再设计一套更大的“映射系统“就可以解决问题了，比如</p><p>​    啊 = 00000000 00000001</p><p>​    哦 = 00000000 00000010</p><p>​    即使用16位二进制（两字节）表示一个汉字，最多可表示 2^16 = 65536 个。</p><p>​    早期中午系统设计的时候，使用GB2312标准，但这套标准有部分的汉字，符号，少数民族用语是没有映射过去的，比如在GB2312中就打不出”镕“字，所以往后就出了编码范围更大的编码表，如GBK、GB18030。这些编码表只有一个区别，就是能表示的汉字或符号范围越来越大了，但相应的，需要映射的二进制位数也越来越大了，即汉字可能需要用2-4位字节(16-32位二进制)表示，存储的成本增加了。</p><p><strong>5.全角和半角</strong></p><p>​    综上，我们知道</p><pre><code>1. 计算机只认识二进制01，所有的字形符号都是通过编码表（映射系统）翻译实现的 2. 在英文系统的编码里，有用一字节表示的标点符号，如英文逗号”，“ 3. 在中文系统的编码表里，有用N(1-4)字节表示的标点符号，如中文逗号”，“</code></pre><p>   语义上我们统称为逗号，但计算机实际表现形式是不同的<br>   英文逗号”,”   在ASCII规则下是 00101100，一字节长，屏幕打印宽度是一个宽度<br>   中文逗号”，” 在GBK规则下是  10100011 10101100，两字节长，屏幕打印宽度是两个宽度</p><p>   半角就是指 ASCII 编码表以内的标点符号，它们都是占一个字节，一个打印宽度的</p><p> 举个栗子🌰：|为分割线 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中文，１２３４，ａｂｃｄ| 全角  </span><br><span class="line">中文，1234，abcd|半角</span><br></pre></td></tr></table></figure><p> 附：中引文对应键位下的字母和符号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">·1234567890-=【】、；‘’，。、qwertyuiop~！@#￥%……&amp;*（）——+&#123;&#125;|：“”《》？ </span><br><span class="line">`1234567890-=[]\;&apos;,./qwertyuiop~!@#$%^&amp;*()_+&#123;&#125;|:&quot;&lt;&gt;?</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      举个栗子🌰：|为分割线 中文，１２３４，ａｂｃｄ| 全角 中文，1234，abcd|半角
    
    </summary>
    
      <category term="沧海拾遗" scheme="https://dingding15yd.github.io/categories/%E6%B2%A7%E6%B5%B7%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="java" scheme="https://dingding15yd.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>找准定位，深耕Java核心技术</title>
    <link href="https://dingding15yd.github.io/2019/12/30/2020%E6%89%BE%E5%87%86%E5%AE%9A%E4%BD%8D%EF%BC%8C%E6%B7%B1%E8%80%95Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>https://dingding15yd.github.io/2019/12/30/2020找准定位，深耕Java核心技术/</id>
    <published>2019-12-30T00:50:28.000Z</published>
    <updated>2020-01-16T00:54:45.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="世界之大，专精、深耕"><a href="#世界之大，专精、深耕" class="headerlink" title="世界之大，专精、深耕"></a>世界之大，专精、深耕</h1><p>切勿在当下信息爆炸的时代左瞻右顾，找准自己的道路，一往无前，没有达到相应的境界，切勿好高骛远，不切实际。</p><p>人生的三大境界：</p><p>第一境界：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 昨夜西风凋碧树 。独上高楼，望尽天涯路。</span><br></pre></td></tr></table></figure><p>​        迷茫的阶段:人生初期，三观没有成型，面对很多问题，会表现出迷茫，不知道该如何选择。初入社会或职场，缺少目标和方向。 </p><p>第二境界：</p><pre><code>2. 衣带渐宽终不悔，为伊消得人憔悴。</code></pre><p>​       奋斗的阶段:目标确立，接下来就是一种实施，努力，或是执着。是已经做出决定后，所表现的奋斗情形 。</p><p>第三境界：</p><pre><code>3. 众里寻他千百度，慕然回首，那人却在灯火阑珊处。</code></pre><p>​        辉煌的阶段:立志追逐的，在足够的积累后，量变成为质变，不经意间已追逐到了。 </p><h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot</span><br><span class="line">RabbitMQ</span><br><span class="line">Shrio</span><br><span class="line">Redis</span><br><span class="line">Elaticsearch</span><br><span class="line">ShardingJDBC</span><br><span class="line">GIT</span><br><span class="line">算法</span><br><span class="line">数据中台(了解)</span><br><span class="line">JVM、GC</span><br><span class="line">NIO、Netty</span><br><span class="line">SpringCloud</span><br></pre></td></tr></table></figure><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.《小狗钱钱》（博多·费舍尔）</span><br><span class="line">2.《富爸爸穷爸爸》（罗伯特·清崎 / 莎伦·莱希特）</span><br><span class="line">3.《财务自由之路》（博多·费舍尔）</span><br><span class="line">4.《30岁前的每一天》（水湄物语）</span><br><span class="line">5.《穷查理宝典》（查理·芒格）</span><br><span class="line">6.干法</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      一往无前虎山行，拨开云雾见光明。
    
    </summary>
    
      <category term="学习路线" scheme="https://dingding15yd.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    
      <category term="java" scheme="https://dingding15yd.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2020找准定位，深耕Java核心技术</title>
    <link href="https://dingding15yd.github.io/2019/12/30/%E6%89%BE%E5%87%86%E5%AE%9A%E4%BD%8D%EF%BC%8C%E6%B7%B1%E8%80%95Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>https://dingding15yd.github.io/2019/12/30/找准定位，深耕Java核心技术/</id>
    <published>2019-12-30T00:50:28.000Z</published>
    <updated>2020-01-16T01:13:03.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="世界之大，专精、深耕"><a href="#世界之大，专精、深耕" class="headerlink" title="世界之大，专精、深耕"></a>世界之大，专精、深耕</h1><p>切勿在当下信息爆炸的时代左瞻右顾，找准自己的道路，一往无前，没有达到相应的境界，切勿好高骛远，不切实际。</p><p>人生的三大境界：</p><p>第一境界：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 昨夜西风凋碧树 。独上高楼，望尽天涯路。</span><br></pre></td></tr></table></figure><p>​        迷茫的阶段:人生初期，三观没有成型，面对很多问题，会表现出迷茫，不知道该如何选择。初入社会或职场，缺少目标和方向。 </p><p>第二境界：</p><pre><code>2. 衣带渐宽终不悔，为伊消得人憔悴。</code></pre><p>​       奋斗的阶段:目标确立，接下来就是一种实施，努力，或是执着。是已经做出决定后，所表现的奋斗情形 。</p><p>第三境界：</p><pre><code>3. 众里寻他千百度，慕然回首，那人却在灯火阑珊处。</code></pre><p>​        辉煌的阶段:立志追逐的，在足够的积累后，量变成为质变，不经意间已追逐到了。 </p><h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot</span><br><span class="line">RabbitMQ</span><br><span class="line">Shrio</span><br><span class="line">Redis</span><br><span class="line">Elaticsearch</span><br><span class="line">ShardingJDBC</span><br><span class="line">GIT</span><br><span class="line">算法</span><br><span class="line">数据中台(了解)</span><br><span class="line">JVM、GC</span><br><span class="line">NIO、Netty</span><br><span class="line">SpringCloud</span><br></pre></td></tr></table></figure><h3 id="公众号推荐"><a href="#公众号推荐" class="headerlink" title="公众号推荐"></a>公众号推荐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DevOps (Docker and Jenkins)           https://github.com/kamranahmedse/developer-roadmap</span><br><span class="line">Java 9 - Java 15</span><br><span class="line">Spring Framework 5</span><br><span class="line">Spring Security 5.0</span><br><span class="line">Spring Boot 2</span><br><span class="line">Hadoop、Spark 和 Kafka</span><br><span class="line">Elasticsearch</span><br><span class="line">ServiceMesh</span><br><span class="line">Serverless</span><br><span class="line">Kotlin</span><br><span class="line">文章地址：https://mp.weixin.qq.com/s/o74IWBQpEfBWLQX7Eld_hg</span><br></pre></td></tr></table></figure><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.《小狗钱钱》（博多·费舍尔）</span><br><span class="line">2.《富爸爸穷爸爸》（罗伯特·清崎 / 莎伦·莱希特）</span><br><span class="line">3.《财务自由之路》（博多·费舍尔）</span><br><span class="line">4.《30岁前的每一天》（水湄物语）</span><br><span class="line">5.《穷查理宝典》（查理·芒格）</span><br><span class="line">6.干法</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      一往无前虎山行，拨开云雾见光明。
    
    </summary>
    
      <category term="学习路线" scheme="https://dingding15yd.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    
      <category term="java" scheme="https://dingding15yd.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 8需要掌握的新特性</title>
    <link href="https://dingding15yd.github.io/2019/12/12/java-8%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://dingding15yd.github.io/2019/12/12/java-8需要掌握的新特性/</id>
    <published>2019-12-12T03:40:04.000Z</published>
    <updated>2020-01-15T03:36:58.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h4 id="Lambda的构成："><a href="#Lambda的构成：" class="headerlink" title="Lambda的构成："></a>Lambda的构成：</h4><p> <img src="/2019/12/12/java-8需要掌握的新特性/1.png" alt></p><h4 id="五种具体形式："><a href="#五种具体形式：" class="headerlink" title="五种具体形式："></a>五种具体形式：</h4><p><img src="/2019/12/12/java-8需要掌握的新特性/2.png" alt></p><p>  此时小括号不可省略。</p><p><img src="/2019/12/12/java-8需要掌握的新特性/3.png" alt></p><p>  此时小括号可以省略，并且参数不用声明类型。</p><p><img src="/2019/12/12/java-8需要掌握的新特性/4.png" alt></p><p>  方法体逻辑复杂时需要使用{ }大括号包裹起来。</p><p><img src="/2019/12/12/java-8需要掌握的新特性/5.png" alt></p><p><img src="/2019/12/12/java-8需要掌握的新特性/6.png" alt></p>]]></content>
    
    <summary type="html">
    
      Lambda表达式、方法引用、Stream流式编程
    
    </summary>
    
      <category term="java-基础" scheme="https://dingding15yd.github.io/categories/java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://dingding15yd.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>简洁明了搞懂时间复杂度</title>
    <link href="https://dingding15yd.github.io/2019/11/21/%E7%AE%80%E6%B4%81%E6%98%8E%E4%BA%86%E6%90%9E%E6%87%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://dingding15yd.github.io/2019/11/21/简洁明了搞懂时间复杂度/</id>
    <published>2019-11-21T07:59:31.000Z</published>
    <updated>2020-01-15T03:36:58.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简洁明了搞懂时间复杂度"><a href="#简洁明了搞懂时间复杂度" class="headerlink" title="简洁明了搞懂时间复杂度"></a>简洁明了搞懂时间复杂度</h1><h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/1.jpg" alt></p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/2.jpg" alt></p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/3.jpg" alt></p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/4.jpg" alt></p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/5.jpg" alt></p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/6.jpg" alt></p><h3 id="时间复杂度的意义"><a href="#时间复杂度的意义" class="headerlink" title="时间复杂度的意义"></a>时间复杂度的意义</h3><p>  究竟什么是时间复杂度呢？让我们来想象一个场景：某一天，小灰和大黄同时加入了一个公司。</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/7.jpg" alt></p><p>  一天过后，小灰和大黄各自交付了代码，两端代码实现的功能都差不多。大黄的代码运行一次要花100毫秒，内存占用5MB。小灰的代码运行一次要花100秒，内存占用500MB。于是…</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/8.jpg" alt></p><p>  由此可见，衡量代码的好坏，包括两个非常重要的指标：</p>  <font color="gree">1.运行时间</font>  <font color="gree">2.占用空间</font><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/9.jpg" alt></p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/10.jpg" alt></p><h3 id="基本操作执行次数"><a href="#基本操作执行次数" class="headerlink" title="基本操作执行次数"></a>基本操作执行次数</h3><p>  关于代码的基本操作执行次数，我们用四个生活中的场景，来做一下比喻：</p><p>  <strong>场景1</strong>：给小灰一条长10寸的面包，小灰每3天吃掉一寸，那么吃掉整个面包需要几天？</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/11.jpg" alt></p><p>  答案自然是 3 x 10 = 30 天。</p><p>  如果面包的长度是 N 寸呢？</p><p>  此时吃掉整个面包，需要 3 x N = 3N 天。</p><p>  如果用一个函数来表达这个相对时间，可以记作 T(n) = 3n。</p><p>  <strong>场景2</strong>：给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸…那么小灰把面包吃的剩下1寸，需要多少天呢？</p><p>  这个问题翻译一下，就是数字16不断地除以2，初几次以后的结果等于1？这里要涉及到数学当中的对数，以2为底，16的对数，可以简写为 log^16。</p><p>  因此，把面包吃得只剩下1寸，需要 5 x log^16 = 5 x 4 = 20天。</p><p>  如果面包的长度是N寸呢？</p><p>  需要 5 x log ^n 天，记作 T(n) = 5 log^n。</p><p>  <strong>场景3</strong>：给小灰一条长10寸的面包和一个鸡腿，小灰每2天吃掉一个鸡腿。那么小灰吃掉整个鸡腿需要多少天呢？</p><p> <img src="/2019/11/21/简洁明了搞懂时间复杂度/12.jpg" alt></p><p>  答案自然是两天。因为只说是吃掉鸡腿，和面包没有关系。</p><p>  如果面包的长度是 N 寸呢？</p><p>  无论面包有多长，吃掉鸡腿的时间仍然是2天，记作是 T(n) = 2。</p><p>  <strong>场景4</strong>：给小灰一条长10寸的面包，小灰吃掉第一个一寸需要1天时间，吃掉第二个一寸需要2天事件，吃掉第三个一寸需要3天时间…每多吃一寸，所花的时间也多一天。那么小灰吃掉整个面包需要多少天呢？</p><p>  答案是从1累加到10的总和，也就是55天。</p><p>  如果面包的长度是 N 寸呢？</p><p>  此时吃掉整个面包，需要 1+2+3+…+n-1+n = (1+n)*n/2 = 0.5n^2 + 0.5n。</p><p>  记作 T(n) = 0.5n^2 + 0.5n</p><p> <img src="/2019/11/21/简洁明了搞懂时间复杂度/13.jpg" alt></p><p>  上面所讲的是吃东西所花费的相对时间，这一思想同样适用于对程序基本操作执行次数的统计。刚才的四个场景，分别对应了程序中最常见的四种执行方式：</p><p>  <strong>场景一</strong>： T(n) = 3n，执行次数是线性的。</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/14.jpg" alt></p><p><strong>场景二</strong>：T(n) = 5 log^n，执行次数是对数的。</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/15.jpg" alt></p><p>  <strong>场景三</strong>：T(n) = 2，执行次数是常量的。</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/16.jpg" alt></p><p>  场景四：T(n) = 0.5^2 + 0.5n，执行次数是一个多项式。</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/17.jpg" alt></p><h3 id="渐进时间复杂度"><a href="#渐进时间复杂度" class="headerlink" title="渐进时间复杂度"></a>渐进时间复杂度</h3><p>  有了基本操作执行次数的函数 T(n)，是否就可以分析和比较一段代码的运行时间了呢？还是有一定的困难。</p><p>  比如算法A的相对时间是 T(n) = 100n，算法B的相对时间是T(n) = 5n^2，这两个到底谁的运行时间更长一些？这就要看n的取值了。</p><p>  所以，这时候有了渐进时间复杂度(asymptotic time complexity)的概念，官方的定义如下：</p><p>  若存在函数 f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数。</p><p>  记作 T(n) = O(f(n))，称 O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p><p>  渐进时间复杂度用大写O来表示，所以也被称为大O表示法。</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/18.jpg" alt></p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/19.jpg" alt></p><p><strong>如何推导出时间复杂度呢？有如下几个原则：</strong></p><ol><li>如果运行时间是常数量级，用常数 1 表示；</li><li>只保留时间函数中的最高阶项；</li><li>如果最高阶项存在，则省去最高阶项前面的系数。                                 </li></ol><p><strong>让我们回头看看刚才的四个场景。</strong></p><p>场景一：T(n) = 3n</p><p>  最高阶项为3n，省去系数3，转化的时间复杂度为：</p><p>  T(n)    =    O(n)</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/20.jpg" alt></p><p>场景二：T(n)  = 5 log^n</p><p>  最高阶项为5 logn，省去系数5，转化的时间复杂度为：</p><p>  T(n)  =  O(log^n)</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/21.jpg" alt></p><p>场景三：T(n)  =  2</p><p>  只有常数量级，转化的时间复杂度为：</p><p>  T(n)  =  O(1)</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/22.jpg" alt></p><p>场景四：T(n)  = 0.5n^2  +  0.5n</p><p>  最高阶项为 0.5n^2，省去系数0.5，转化的时间复杂度为：</p><p>  T(n)  =  O(n^2)</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/23.jpg" alt></p><p>这四种时间复杂度究竟谁用时更长，谁更节省时间呢？稍微思考下就可以得到结论：</p><p>  O(1) &lt; O(log^n) &lt; O(n) &lt; O(n^2)</p><p>在编程的世界中有着各种各样的算法，除了上述的四种场景，还有许多不同形式的时间复杂度，比如：</p><p>  O(n log^n)，O(n^3)，O(m * n)，O(2^n)，O(n!)</p><h3 id="时间复杂度的巨大差异"><a href="#时间复杂度的巨大差异" class="headerlink" title="时间复杂度的巨大差异"></a>时间复杂度的巨大差异</h3><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/24.jpg" alt></p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/25.jpg" alt></p><p>我们来举一个例子：</p><p>算法A的相对时间规模是T(n) = 100n，时间复杂度是O(n)</p><p>算法B的相对时间规模是T(n) = 5n^2，时间复杂度是O(n^2)</p><p>算法A运行在小灰家里的老旧电脑上，算法B运行在某台超级计算机上，运行时间是老旧电脑的100倍。</p><p>那么，随着输入规模n的增长，两种算法谁运行更快呢？</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/26.jpg" alt></p><p>从表格中可以看到，当n的值很小的时候，算法A的运行时间要远大于算法B；当n的值达到1000左右，算法A和算法B的运行时间已经接近；当n的值越来愈大，达到十万、百万时，算法A的优势开始显现，算法B则越来越慢，差距越来越明显。这就是不同时间复杂度带来的差异。</p><p><img src="/2019/11/21/简洁明了搞懂时间复杂度/27.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      一套图搞懂什么是时间复杂度、怎么计算时间复杂度、常见的时间复杂度
    
    </summary>
    
      <category term="java-基础" scheme="https://dingding15yd.github.io/categories/java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://dingding15yd.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>代码这样写规范 - 1</title>
    <link href="https://dingding15yd.github.io/2019/11/20/%E4%BB%A3%E7%A0%81%E8%BF%99%E6%A0%B7%E5%86%99%E8%A7%84%E8%8C%83-1/"/>
    <id>https://dingding15yd.github.io/2019/11/20/代码这样写规范-1/</id>
    <published>2019-11-20T07:56:08.000Z</published>
    <updated>2020-01-15T03:36:58.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码这样写规范-1"><a href="#代码这样写规范-1" class="headerlink" title="代码这样写规范 - 1"></a>代码这样写规范 - 1</h1><h3 id="一、迭代-entrySet-获取Map的key-和-value"><a href="#一、迭代-entrySet-获取Map的key-和-value" class="headerlink" title="一、迭代 entrySet() 获取Map的key 和 value"></a>一、迭代 entrySet() 获取Map的key 和 value</h3><p>  当需要获取Map集合中的主键 key 值时，迭代keySet() 是正确的，但是，当需要主键key和取值value时，迭代entrySet() 才是更高效的做法，其比先迭代keySet()后再去通过get取值性能更佳。</p><p>  反例：</p><p><img src="/2019/11/20/代码这样写规范-1/1.png" alt></p><p>  正例：</p><p><img src="/2019/11/20/代码这样写规范-1/2.png" alt></p><h3 id="二、使用-Collection-isEmpty-检测空"><a href="#二、使用-Collection-isEmpty-检测空" class="headerlink" title="二、使用 Collection.isEmpty() 检测空"></a>二、使用 Collection.isEmpty() 检测空</h3><p>  使用Collection.size() 来检测是否为空在逻辑上没有问题，但是使用 Collection.isEmpty(）使得代码更易读，并且可以获得更好的性能，除此之外，任何Collection.isEmpty() 实现的时间复杂度都是 O(1)，并不需要多次遍历，但是通过 Collection.size() 方法实现的时间复杂度可能是O(n)。</p><p>  反例：</p><p><img src="/2019/11/20/代码这样写规范-1/3.png" alt></p><p>  正例：</p><p><img src="/2019/11/20/代码这样写规范-1/4.png" alt></p><h3 id="三、若需频繁调用-Collection-contains-方法则使用-Set"><a href="#三、若需频繁调用-Collection-contains-方法则使用-Set" class="headerlink" title="三、若需频繁调用 Collection.contains 方法则使用 Set"></a>三、若需频繁调用 Collection.contains 方法则使用 Set</h3><p>  在Java集合类库中，List 的contains() 普遍时间复杂度为 O(n)，若代码中需要频繁调用contains() 查找数据则先将集合list转换成 HashSet 实现，将 O(n) 的时间复杂度将为 O(1)。</p><p>反例：</p><p><img src="/2019/11/20/代码这样写规范-1/5.png" alt></p><p>  正例：</p><p><img src="/2019/11/20/代码这样写规范-1/6.png" alt></p><h3 id="四、使用静态代码块实现赋值静态成员变量"><a href="#四、使用静态代码块实现赋值静态成员变量" class="headerlink" title="四、使用静态代码块实现赋值静态成员变量"></a>四、使用静态代码块实现赋值静态成员变量</h3><p>  对于集合类型的静态成员变量，应该使用静态代码块赋值，而不是使用集合来赋值。</p><p>反例：</p><p><img src="/2019/11/20/代码这样写规范-1/7.png" alt></p><p>正例：</p><p><img src="/2019/11/20/代码这样写规范-1/8.png" alt></p><h3 id="五、工具类中屏蔽构造函数"><a href="#五、工具类中屏蔽构造函数" class="headerlink" title="五、工具类中屏蔽构造函数"></a>五、工具类中屏蔽构造函数</h3><p>  工具类是一堆静态字段和函数的集合，其不应该被实例化，但是，Java为每个没有明确定义构造函数的类添加了一个隐式公有构造函数，为了避免不必要的实例化，应该显式定义私有构造函数来屏蔽这个隐式公有构造函数。</p><p>反例：</p><p><img src="/2019/11/20/代码这样写规范-1/9.png" alt></p><p>正例：</p><p><img src="/2019/11/20/代码这样写规范-1/10.png" alt></p><h3 id="六、字符串转化使用-String-valueOf-value-代替-“-“-value"><a href="#六、字符串转化使用-String-valueOf-value-代替-“-“-value" class="headerlink" title="六、字符串转化使用 String.valueOf(value) 代替 “ “ + value"></a>六、字符串转化使用 String.valueOf(value) 代替 “ “ + value</h3><p>  把其他对象或类型转化为字符串时，使用 String.valueOf(value) 比 “ “ + value 的效率更高。</p><p>反例：</p><p><img src="/2019/11/20/代码这样写规范-1/11.png" alt></p><p>正例：</p><p><img src="/2019/11/20/代码这样写规范-1/12.png" alt></p><h3 id="七、避免使用BigDecimal-double"><a href="#七、避免使用BigDecimal-double" class="headerlink" title="七、避免使用BigDecimal(double)"></a>七、避免使用BigDecimal(double)</h3><p>  BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。</p><p>反例：</p><p><img src="/2019/11/20/代码这样写规范-1/13.png" alt></p><p>正例：</p><p><img src="/2019/11/20/代码这样写规范-1/14.png" alt></p><h3 id="八、返回空数组和集合而非null"><a href="#八、返回空数组和集合而非null" class="headerlink" title="八、返回空数组和集合而非null"></a>八、返回空数组和集合而非null</h3><p>  若程序运行返回null，需要调用方强制检测null，否则就会抛出空指针异常，返回空数组或空集合，有效的避免了调用方因为未检测null而抛出空指针异常的情况，还可以删除调用方检测null的语句使代码更简洁。</p><p>反例：</p><p><img src="/2019/11/20/代码这样写规范-1/15.png" alt></p><p>正例：</p><p><img src="/2019/11/20/代码这样写规范-1/16.png" alt></p><h3 id="九、枚举的属性字段必须是私有且不可变"><a href="#九、枚举的属性字段必须是私有且不可变" class="headerlink" title="九、枚举的属性字段必须是私有且不可变"></a>九、枚举的属性字段必须是私有且不可变</h3><p>  枚举通常被当作常量使用，如果枚举中存在公共属性字段或设置字段方法，那么这些枚举常量的属性很容易被修改，理想情况下，枚举字段的属性字段是私有的，并在私有构造函数中赋值，没有对应的Setter方法，最好加上final修饰符。</p><p>反例：</p><p><img src="/2019/11/20/代码这样写规范-1/17.png" alt></p><p>正例：</p><p><img src="/2019/11/20/代码这样写规范-1/18.png" alt></p><p>十、String.split(String  regex)部分关键字需要转义</p><p>  使用字符串String.split()时，传入的分隔字符串是正则表达式，则部分关键字(比如 . [] () |等)需要转义。</p><p>反例：</p><p><img src="/2019/11/20/代码这样写规范-1/19.png" alt></p><p>正例：</p><p><img src="/2019/11/20/代码这样写规范-1/20.png" alt></p>]]></content>
    
    <summary type="html">
    
      集合遍历、判空、字符串拼接、工具类实例化问题、枚举等方面规范代码。
    
    </summary>
    
      <category term="java-基础" scheme="https://dingding15yd.github.io/categories/java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://dingding15yd.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Javaa开发路线图 - 2019</title>
    <link href="https://dingding15yd.github.io/2019/11/07/Java%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE-2019/"/>
    <id>https://dingding15yd.github.io/2019/11/07/Java开发路线图-2019/</id>
    <published>2019-11-07T07:27:18.000Z</published>
    <updated>2020-01-15T03:36:58.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Java-8的各项功能"><a href="#1、Java-8的各项功能" class="headerlink" title="1、Java 8的各项功能"></a>1、Java 8的各项功能</h3><p>   Java程序员应该学习并掌握的下一个重要API是Java 8的各项功能。可以毫不夸张地说，这些功能彻底改变了如今Java的编程方式。 </p><p>   因此，作为一名Java开发人员，您不应该错过了解与使用<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247490334&amp;idx=1&amp;sn=45e3daa153a744ada788d2f4de199192&amp;chksm=eb539e28dc24173e66d7fc010ac5c7d4fc6e69cbcc722ecc07df25b3344d63852c0e367f3904&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Lambda</a>表达式、Stream API、<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484481&amp;idx=1&amp;sn=b4a0586ce8c9a798d26a3eb6273ffa5d&amp;chksm=eb538177dc2408613493aa78273683c007427be4b217b41dc8d8b5e36435c398ce937f1af799&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Optional</a>类、以及全新Date and Time API的机会。 </p><p>  Java 8已经发布5年多了，如今大多数库都已停止了支持低于Java 8的版本。因此如果您想顺利地实现Java应用程序的编写与调试的话，请赶快抓紧时间学习Java 8的各项新功能。</p><p>关注微信公众号：Java技术栈，在后台回复：Java，可以获取我整理的 N 篇最新 Java 8－12 新特性教程，都是干货。</p><p><img src="/2019/11/07/Java开发路线图-2019/1.png" alt></p><h3 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h3><p>   测试，尤其是单元测试、集成测试和自动化测试，是任何Java开发人员必修的一项基本技能。其中，JUnit和Mockito是两种被Java开发人员最为熟悉、且欢迎的单元测试和模拟库。</p><p>   当然，您也可以去学习一下更高级的程序库，例如：用于业务驱动测试的Cucumber，用于集成测试的Robot Framework，以及您肯定“绕不开”的JUnit。 </p><p>   在常见的PowerMock、Mockito和EasyMock三种模拟库中，我强烈建议您学习Mockito。由于目前有许多Java开发人员和公司都在使用它，因此它已逐渐成为了在Java中创建模拟对象的标准库。 </p><h3 id="3、实用程序库"><a href="#3、实用程序库" class="headerlink" title="3、实用程序库"></a>3、实用程序库</h3><p>   一直以来，Java都拥有着丰富的开源程序库，它们可以帮助开发人员实现从日志记录到机器学习，从发送HTTP请求到解析JSON等，几乎所有的工作。 </p><p>   值得一提的是：Apache Commons和Google Guava这两个实用程序库，它们是Java JDK库的有效补充。 </p>]]></content>
    
    <summary type="html">
    
      Java 8 、单元测试、实用开源程序库
    
    </summary>
    
      <category term="java-基础" scheme="https://dingding15yd.github.io/categories/java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://dingding15yd.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>spring boot - 1</title>
    <link href="https://dingding15yd.github.io/2019/11/05/spring-boot-1/"/>
    <id>https://dingding15yd.github.io/2019/11/05/spring-boot-1/</id>
    <published>2019-11-05T10:54:52.000Z</published>
    <updated>2020-01-15T03:36:58.264Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/11/05/spring-boot-1/1.png" alt></p><h3 id="Spring-Boot-的背景"><a href="#Spring-Boot-的背景" class="headerlink" title="Spring  Boot 的背景"></a>Spring  Boot 的背景</h3><p>  得益于Spring框架的流行，它的两把利器：IOC 和 AOP，IOC帮助我们管理对象的依赖关系，极大减少对象的耦合性，而AOP的切面编程可以方便使用动态代理来实现各种动态方法功能（如事务、缓存、日志等）。</p><p>  而要集成Spring框架，必须要用到XML配置文件，或者注解式的 Java 代码配置。无论使用XML或者代码配置方式，都需要对相关组件的配置有足够的了解，然后在编写大量冗长的配置代码。</p><h1 id="什么是Spring-Boot？"><a href="#什么是Spring-Boot？" class="headerlink" title="什么是Spring  Boot？"></a>什么是Spring  Boot？</h1><p>​    Spring boot是spring开源组织的子项目，是Srping组件一站式解决方案，简化了Spring的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><p>​    Spring Boot不但能创建传统的 war 包，还能创建独立的不依赖于任何外部容器（如：Tomcat）的独立应用，使用java -jar 命令就能启动。</p><h3 id="Spring-Boot的优点"><a href="#Spring-Boot的优点" class="headerlink" title="Spring  Boot的优点"></a>Spring  Boot的优点</h3><ul><li><p>独立运行</p><p>Spring boot内嵌各种servlet容器，Tomcat、Jetty等，现在不再需要打包成war包部署到容器中，Spring boot只要只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。</p></li><li><p>简化配置</p><p>spring-boot-starter-web启动器自动依赖其他组件，简化了maven配置。</p><p>使用Maven命令：mvn dependency：tree 也可以看到完整的依赖树：<img src="/2019/11/05/spring-boot-1/2.png" alt></p></li><li><p>自动配置</p></li></ul><p>​           spring boot能根据当前类路径下的类、jar包来自动bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。  </p><ul><li><p>无代码生成和XML配置</p><p>spring boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是spring4.x的核心功能之一。</p></li><li><p>应用监控</p><p>spring boot提供一系列端点可以监控服务及应用，做健康检测。</p></li></ul><h3 id="Spring-Boot的缺点"><a href="#Spring-Boot的缺点" class="headerlink" title="Spring Boot的缺点"></a>Spring Boot的缺点</h3><p>  1、Spring boot虽然上手很容易，但需要了解核心技术和流程，所以一旦遇到问题就很棘手，因为什么东西都集成了，自动配置化。这样需要对配置信息非常熟悉，找起问题来不是很容易。</p><p>  2、原始 Spring 项目很难平滑迁移到Spring boot 框架上，因为有些老旧的XML配置无法通过Java来配置，还需要额外的XML文件就不是很完美。还有，之前独立的Tomcat什么参数都在线上配置好了，改为内置的Tomcat就会遇到很多问题。</p><h1 id="Spring-Boot的四大核心特性"><a href="#Spring-Boot的四大核心特性" class="headerlink" title="Spring  Boot的四大核心特性"></a>Spring  Boot的四大核心特性</h1><p>  spring boot最重要的四大核心特性是 自动配置、起步依赖、Actuator、命令行界面(CLI)。其中CLI是Spring boot 的可选特性，虽然它功能强大，但也引入一套不太常规的开发模型，因此不做详解。</p><h3 id="一、抛砖引玉：Spring-IOC容器"><a href="#一、抛砖引玉：Spring-IOC容器" class="headerlink" title="一、抛砖引玉：Spring IOC容器"></a>一、抛砖引玉：Spring IOC容器</h3><p>  SpringApplication 启动类是对一个典型的Spring应用的启动流程进行了扩展，因此，彻底理解Spring容器是打开Spring Boot大门的一把钥匙。</p><h3 id="1-1、Spring-IOC容器"><a href="#1-1、Spring-IOC容器" class="headerlink" title="1.1、Spring IOC容器"></a>1.1、Spring IOC容器</h3><p>​    把spring ioc容器比作一间餐馆，当你来到餐馆，通常会直接招呼服务员：点菜！至于菜的原料是什么？如何用原料把菜做出来？who care。ioc 容器也是一样的，你告诉他需要哪个bean，他就把相应的实例（instance）扔给你，至于这个bean是否依赖其他组件，怎么完成初始化，根本不需要你的关心。</p><p>  作为餐馆，想要做出菜肴，得知道菜的原料和菜谱，同样的，IOC容器想要管理各个业务对象以及它们之间的依赖关系，需要通过某种途径来记录和管理这些信息。 BeanDefinition 对象就承担了这个责任：容器中的每一个bean都会有一个对应的BeanDefinition实例，该实例负责保存bean对象的所有必要信息，包括bena对象的class类型、是否是抽象类、构造方法和参数、其他属性等。当客户端向容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的bean实例。</p><p>  原材料已经准备好（把BeanDefinition看成原料），开始做菜吧，等等，你还需要一份菜谱，而BeanDefinitionRegistry 和 BeanFactory就是这本菜谱，BeanDefinitionRegistry 抽象出bean的注册逻辑，而BeanFactory则抽象出了bean的管理逻辑，而各个BeanFactory的实现类就具体承担了bean的注册以及管理工作。他们之间的关系如下图：<img src="/2019/11/05/spring-boot-1/3.jpg" alt></p><p>  DefaultListableBeanFactory作为一个比较通用的BenaFactory实现、它同时也实现了BeanDefinitionRegistry接口，因此它就承担了Bean的注册管理工作。从图中也可以看出，BeanFactory接口中主要包括getBean、containBean、getType、getAliases等管理bean的方法，而BeanDefinitionRegistry接口则包括registerBeanDefinition、removeBeanDefinition、getBeanDedinition等注册管理BeanDefinition的方法。</p><p>  下面通过一段简单的代码来模拟BeanFactory底层是如何工作的：<img src="/2019/11/05/spring-boot-1/4.png" alt></p><p>  这段代码仅为说明BeanFactory底层的大致工作流程，实际会更复杂，比如bean之间的依赖关系可能定义在外部配置文件（XML/Properties）中、也可能是注解方式。Spring Ioc容器的整个工作流程大致可以分为两个阶段：</p><blockquote><p>1.容器启动阶段</p></blockquote><p>  容器启动时，会通过某种途径加载ConfigurationMetaData。除了代码方式比较直接外，在大部分情况下，容器需要依赖某些工具类，比如BeanDefinitionReader，BeanDefinitionReader会对加载的ConfigurationMetaData进行解析和分析，并将分析后的信息组装为相应的BeanDefinition，最后把这些保存了bean定义的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器的启动工作就完成了。这个阶段主要完成一些准备性工作，更侧重于bean对象管理信息的收集，当然一些验证性或辅助性的工作也在这一阶段完成。</p><p>看一个简单例子，以前，所有的bean都定义在XML配置文件中，下面的代码将模拟BeanFactory如何从配置文件中加载bean的定义以及依赖关系：<img src="/2019/11/05/spring-boot-1/5.png" alt></p><blockquote><p>2.Bean的实例化阶段</p></blockquote><p>  经过第一个阶段，所有bean定义都通过BeanDefinition的方式注册到BeanDefinitionRegistry中，当某个请求通过容器的getBean方法请求某个对象，或者因为依赖关系容器需要隐式的调用getBean时，就会触发第二阶段的活动，容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完成后，容器会立刻将其返回给请求方法使用。</p><p>  BeanFactory只是Spring Ioc容器的一种实现，如果没有特殊指定，它采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。而在实际场景下，我们更多的使用另外一种类型的容器：ApplicationContext，它构建在BeanFactory之上，属于更高级的容器，除了具有BeanFactory的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的bean，在容器启动时全部完成初始化和依赖注入操作。</p><h3 id="1-2、Spring容器扩展机制"><a href="#1-2、Spring容器扩展机制" class="headerlink" title="1.2、Spring容器扩展机制"></a>1.2、Spring容器扩展机制</h3><p>  IoC容器负责管理容器中所有bean的生命周期，而在bean生命周期的不同阶段，Spring提供了不同的扩展点来改变bean的命运。在容器的启动阶段，BeanFactoryPostProcessor允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做一些额外的操作，比如修改bean定义的某些属性或者增加其它信息等。</p><p>  如果要自定义扩展类，通常需要实现 org.springframework.beans.factory.config.BeanFactoryPostProcessor接口，与此同时，因为容器中可能有多个BeanFactoryPostProcessor，可能还需要实现 org.springframework.core.Ordered接口，以保证BeanFactoryPostProcessor按照顺序执行。Spring 提供了为数不多的BeanFactoryPostProcessor实现，我们以PropertryPlaceholderConfigurer来说明大致工作流程。</p><p>  在Spring项目的XML配置文件中，经常可以看到许多配置项的值使用占位符，而将占位符所代表的值单独配置到独立的 properties 文件中，这样可以将散落在不同XML文件中的配置集中管理，而且也方便运维根据不同的环境进行匹配不同的值。这个非常实用的功能就是由 PropertyPlaceholderConfigurer负责实现的。</p><p>  根据前文，当BeanFactory在第一阶段加载完所有配置信息时，BeanFactory中保存的对象的属性还是以占位符方式存在的，比如 ${jdbc.mysql.url}。当 PropertyPlaceholderConfigurer 作为BeanFactoryProcessor被应用时，它会使用properties配置文件中的值来替换相应的BeanDefinition中占位符所表示的属性值。当需要实例化bean时，bean定义中的属性值就已经被替换我们配置的值。当然其实现比上面描述的要复杂一些，这里仅说明其大致工作原理，更详细的实现可以参考源码。</p><p>  与之相似的，还有BeanPostProcessor，其存在于对象实例化阶段。跟BeanFactoryPostProcessor类似，它会处理容器内所有符合条件并且已经实例化后的对象。简单的对比，BeanFactoryPostProcessor处理bean的定义，而BeanPostProcessor则处理bean完成实例化后的对象。BeanPostProcessor定义了两个接口：<img src="/2019/11/05/spring-boot-1/6.png" alt></p><p>  为了理解这两个方法执行的时机，简单了解bean的整个生命周期：(Bean的实例化过程)<img src="/2019/11/05/spring-boot-1/7.png" alt></p><p>  postProcessBeforeInitialization()方法与postProcessAfterInitialization()分别对应图中前置处理和后置处理两个步骤将执行的方法。这两个方法中都传入了bean对象实例的引用，为扩展容器的对象实例化过程提供了很大便利，在这几乎可以对传入的实例执行任何操作。注解、AOP等功能的实现均大量使用了 BeanPostProcessor，比如有一个自定义注解，你完全可以实现 BeanPostProcessor 的接口，在其中判断bean对象的脑袋上是否有该注解，如果有，你可以对这个bean实例执行任何操作，想想是不是非常简单？</p><p>  再来看一个更常见的例子，在Spring中经常能看到各种各样的Aware接口，其作用就是在对象实例化完成后将Aware接口中规定的依赖注入到当前实例中。比如最常见的ApplicationContextAware接口，实现了这个接口的类都可以获得一个ApplicationContext对象。当容器中 每个对象的实例化过程走到BeanPostProcessor前置处理这一步时，容器会检测到之前注册到容器的ApplicationContextAwareProcessor，然后就会调用其postProcessBeforeInitialization()方法，检查并设置Aware相关依赖。看看代码吧，是不是很简单： <img src="/2019/11/05/spring-boot-1/8.png" alt></p><h3 id="二、夯实基础：JavaConfig与常见Annotation"><a href="#二、夯实基础：JavaConfig与常见Annotation" class="headerlink" title="二、夯实基础：JavaConfig与常见Annotation"></a>二、夯实基础：JavaConfig与常见Annotation</h3><h4 id="2-1、javaconfig"><a href="#2-1、javaconfig" class="headerlink" title="2.1、javaconfig"></a>2.1、javaconfig</h4><p>   我们知道 bean是Spring IOC中非常核心的概念，Spring容器负责bean的生命周期的管理。在最初，Spring使用XML配置文件的方式来描述bean的定义以及相互间的依赖关系，但随着Spring的发展，越来越多的人对这种方式表示不满，因为Spring项目的所有业务类均以bean的形式配置在XML文件中，造成了大量的XML文件，使项目变得复杂且难以管理。 </p><p>   后来，基于纯Java Annotation依赖注入框架 Guice出世，其性能明显优于采用XML方式的Spring，甚至有部分人认为， Guice可以完全取代Spring（ Guice仅是一个轻量级IOC框架，取代Spring还差的挺远）。正是这样的危机感，促使Spring及社区推出并持续完善了 JavaConfig子项目，它基于Java代码和Annotation注解来描述bean之间的依赖绑定关系。比如，下面是使用XML配置方式来描述bean的定义： <img src="/2019/11/05/spring-boot-1/9.png" alt></p><p>  而基于JavaConfig的配置形式是这样的：<img src="/2019/11/05/spring-boot-1/10.png" alt></p><p>   如果两个bean之间有依赖关系的话，在XML配置中应该是这样： <img src="/2019/11/05/spring-boot-1/11.png" alt></p><p>   而在JavaConfig中则是这样： <img src="/2019/11/05/spring-boot-1/12.png" alt></p><p>   你可能注意到这个示例中，有两个bean都依赖于dependencyService，也就是说当初始化bookService时会调用 dependencyService()，在初始化otherService时也会调用 dependencyService()，那么问题来了？这时候IOC容器中是有一个dependencyService实例还是两个？这个问题留着大家思考吧，这里不再赘述。 </p><h4 id="2-2、-ComponentScan"><a href="#2-2、-ComponentScan" class="headerlink" title="2.2、@ComponentScan"></a>2.2、@ComponentScan</h4><p>   @ComponentScan 注解对应XML配置形式中的 <a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>元素，表示启用组件扫描，Spring会自动扫描所有通过注解配置的bean，然后将其注册到IOC容器中，我们可以通过 basePackages 等属性来指定 @ComponentScan 自动扫描的范围，如果不指定，默认从声明@ComponentScan所在类的package进行扫描。正因为如此，SpringBoot的启动类都默认在 src/main/java 下。</p><h4 id="2-3、-Import"><a href="#2-3、-Import" class="headerlink" title="2.3、@Import"></a>2.3、@Import</h4><p>  @Import注解用于导入配置类，举个简单的例子：<img src="/2019/11/05/spring-boot-1/13.png" alt></p><p>   现在有另外一个配置类，比如： MoonUserConfiguration，这个配置类中有一个bean依赖于MoonBookConfiguration中的bookService，如何将这两个bean组合在一起？借助 @Import即可： <img src="/2019/11/05/spring-boot-1/14.png" alt></p><p>   需要注意的是，在4.2之前， @Import注解只支持导入配置类，但是在4.2之后，它支持导入普通类，并将这个类作为一个bean的定义注册到IOC容器中。 </p><h4 id="2-4、-Conditional"><a href="#2-4、-Conditional" class="headerlink" title="2.4、@Conditional"></a>2.4、@Conditional</h4><p>   @Conditional注解表示在满足某种条件后才初始化一个bean或者启用某些配置。它一般用在由 @Component、 @Service、 @Configuration等注解标识的类上面，或者由 @Bean标记的方法上。如果一个 @Configuration类标记了 @Conditional，则该类中所有标识了 @Bean的方法和 @Import注解导入的相关类将遵从这些条件。 </p><p>   在Spring里可以很方便的编写你自己的条件类，所要做的就是实现 Condition接口，并覆盖它的 matches()方法。举个例子，下面的简单条件类表示只有在 Classpath里存在 JdbcTemplate类时才生效： <img src="/2019/11/05/spring-boot-1/15.png" alt></p><p>   当你用Java来声明bean的时候，可以使用这个自定义条件类： <img src="/2019/11/05/spring-boot-1/16.png" alt></p><p>   这个例子中只有当 JdbcTemplateCondition类的条件成立时才会创建MyService这个bean。也就是说MyService这bean的创建条件是 classpath里面包含 JdbcTemplate，否则这个bean的声明就会被忽略掉。 </p><p>  SpringBoot定义了很多有趣的条件，并把他们运用到了配置类上，这些配置类构成了 SpringBoot的自动配置的基础。 SpringBoot运用条件化配置的方法是：定义多个特殊的条件化注解，并将它们用到配置类上。下面列出了 SpringBoot提供的部分条件化注解：<img src="/2019/11/05/spring-boot-1/17.png" alt></p><p>2.5、@ConfigurationProperties 与 @EnableConfigurationProperties</p><p>   当某些属性的值需要配置的时候，我们一般会在 application.properties文件中新建配置项，然后在bean中使用 @Value注解来获取配置的值，比如下面配置数据源的代码。 <img src="/2019/11/05/spring-boot-1/18.png" alt></p><p>   使用 @Value注解注入的属性通常都比较简单，如果同一个配置在多个地方使用，也存在不方便维护的问题（考虑下，如果有几十个地方在使用某个配置，而现在你想改下名字，你改怎么做？）。对于更为复杂的配置，Spring Boot提供了更优雅的实现方式，那就是 @ConfigurationProperties注解。我们可以通过下面的方式来改写上面的代码：</p><p> <img src="/2019/11/05/spring-boot-1/19.png" alt></p><p>   @ConfigurationProperties对于更为复杂的配置，处理起来也是得心应手，比如有如下配置文件： <img src="/2019/11/05/spring-boot-1/20.png" alt></p><p>   可以定义如下配置类来接收这些属性 <img src="/2019/11/05/spring-boot-1/21.png" alt></p><p>   @EnableConfigurationProperties注解表示对 @ConfigurationProperties的内嵌支持，默认会将对应Properties Class作为bean注入的IOC容器中，即在相应的Properties类上不用加 @Component注解。 </p><p>   《<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247486895&amp;idx=2&amp;sn=1d49a0de72f9dee2c434ae905d5bc2e4&amp;chksm=eb538899dc24018ffb0e618abfe7e2223da20e5b8a2d5be36267769779a82701699cd5476748&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 配置加载顺序详解</a>》了解一下。 </p><h3 id="三、削铁如泥：SpringFactoriesLoader详解"><a href="#三、削铁如泥：SpringFactoriesLoader详解" class="headerlink" title="三、削铁如泥：SpringFactoriesLoader详解"></a>三、削铁如泥：SpringFactoriesLoader详解</h3><p>  JVM提供了3种类加载器：BootstrapClassLoader、ExtClassLoader、AppClassLoader分别加载 Java核心类库、扩展类库以及应用的类路径(CLASSPATH)下的类库。JVM通过双亲委派模型进行类的加载，我们也可以通过继承 java.lang.classloader实现自己的类加载器。</p><p>  何为双亲委派模型？当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的BootstrapClassLoader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。<img src="/2019/11/05/spring-boot-1/22.png" alt></p><p>  采用双亲委派模型的一个好处是保证不同类加载器最终得到的都是一个对象，这样就可以保证 Java 核心库的类型安全，比如，加载位于rt.jar包中的java.lang.Object类，不管是哪个加载器加载这个类，最终都是委托给顶层的BootStrapClassLoader来加载的，这样就可以保证任何的类加载器最终得到的都是同样一个Object对象。查看ClassLoader的源码，对双亲委派模型会更有直观的认识：<img src="/2019/11/05/spring-boot-1/23.png" alt></p><p>  但双亲委派模型并不能解决所有的类加载器问题，比如，Java提供了很多服务提供者接口（ServiceProviderProviderInterface，SPI），允许第三方为这些接口提供实现。常见的SPI有JDBC、JNDI、JAXP等，这些SPI的接口有核心类库提供，却由第三方实现，这样就存在一个问题：SPI的接口是Java核心库的一部分，是由BootStrapClassLoader来加载的。BootStrapClassLoader是无法找到SPI的实现类的，因为它只加载Java的核心库，他也不能代理给AppClassLoader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题。</p><p>  线程上下文类加载器（ContextClassLoader）正好解决了这个问题。从名称上来看，可能会误解为它是一种新的类加载器，实际上，它仅仅是Thread类的一个变量而已，可以通过setContextClassLoader（ClassLoader）和 getContextClassLoader（）来设置和获取该对象。如果不做任何的设置，Java应用的线程的上下文类加载器就是AppClassLoader。在核心类库使用SPI接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到SPI实现的类。线程上下文类加载器在很多SPI的实现中都会用到。但在JDBC中，你可能会看到一种更直接的实现方式，比如，JDBC驱动管理java.sql.Driver中的loadInitialDrivers()方法中，你可以直接看到JDK是如何加载驱动的：</p><p>  <img src="/2019/11/05/spring-boot-1/24.png" alt></p><p>  其实讲解线程上下文类加载器，最主要的是在看到 Thread.currentThread().getClassLoader() 和 Thread.currentThread().getContextClassLoader() 时不会一脸懵逼，这两者除了在许多底层框架中取得的ClassLoader可能会有所不同外，其他大多数业务场景下都是一样的，大家只要知道它是为了解决什么问题存在的即可。</p>  <font color="gree">类加载器除了加载class外，还有一个非常重要的功能，就是加载资源，它可以从jar包中读取任何资源</font>，比如，ClassLoader.getResource(String name) 就是用于读取jar包中的资源文件，其代码如下：<img src="/2019/11/05/spring-boot-1/25.png" alt><br><br>  它的逻辑其实和类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到BootStrapClassLoader，最后才轮到自己查找。<font color="gree">而不同的类加载器负责扫描不同路径下的jar包，就如同加载class一样，最后会扫描所有的jar包，找到符合条件的资源文件。</font><p>  类加载器的 findResource(name) 会遍历其负责加载的所有jar包，找到jar包中名称为name的资源文件，这里的资源可以是任何资源，甚至是.class文件，比如下面的示例，用于查找 Array.class 文件：<img src="/2019/11/05/spring-boot-1/26.png" alt></p><p>  运行后得到如下结果：<img src="/2019/11/05/spring-boot-1/27.png" alt></p><p>  这时候再回到我们开头要解析的 SpringFactoriesLoader，你会奇怪上面讲了一堆 ClassLoader 是几个意思？看下它的源码你就知道了：<img src="/2019/11/05/spring-boot-1/28.png" alt></p><p>  有了前面关于ClassLoader的知识，再来理解这段代码，是不是感觉豁然开朗，从 ClassPath 下的每个jar包中搜寻所有 META-INF/spring.factories 配置文件，然后解析 properties 文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅会去 ClassPath 路径下查找，会扫描所有路径下的 Jar 包，只不过这个文件只会在 ClassPath 下的jar包。来简单看下 spring.factories 文件的内容吧：<img src="/2019/11/05/spring-boot-1/29.png" alt></p><p>  执行 loadFactoryNames(EnableAutoConfiguration.class，classLoader)后，得到对应的一组 @Configuration类，我们就可以通过反射实例化这些类然后注入到IOC容器中，最后容器里就有了一系列标注了 @Configuration 的javaConfig形式的配置类。</p><p>  这就是 SpringFactoriesLoader，它本质上属于Spring 框架私有的一种扩展方案，类似SPI，Spring Boot在Spring基础上的很多核心功能都是基于此，希望大家可以理解。</p><h3 id="四、另一件武器：Spring容器的事件监听机制"><a href="#四、另一件武器：Spring容器的事件监听机制" class="headerlink" title="四、另一件武器：Spring容器的事件监听机制"></a>四、另一件武器：Spring容器的事件监听机制</h3><p>  过去，事件监听机制多用于图形界面编程，比如：点击按钮、在文本框输入内容等操作被称为事件，而当事件触发时，应用程序做出一定的响应则表示应用监听了这个事件，<font color="gree">而在服务器端，事件的监听机制更多的用于异步通知以及监控和异常处理。</font>Java提供了实现事件监听机制的两个基础类：自定义事件类型扩展自 java.util.EventObject、事件的监听器扩展自 java.util.EventListener。来看一个简单的实例：简单的监控一个方法的耗时。</p><p>  首先定义事件类型，通常的做法是扩展EventObject，随着事件的发生，相应的状态通常都封装在此类中：<img src="/2019/11/05/spring-boot-1/30.png" alt></p><p>  事件发布之后，相应的监听器即可对该类型的事件进行处理，我们可以在方法开始执行之前发布一个 begin 事件，在方法执行结束之后发布一个end事件，相应地，事件监听器需要提供方法会对这两种情况下接收到的事件进行处理：</p><p><img src="/2019/11/05/spring-boot-1/31.png" alt></p><p>  事件监听器接口针对不同的事件发布实际提供相应的处理方法定义，最重要的是，其方法只接收MthodMonitorEvent 参数，说明这个监听器类只负责监听器对应的事件并进行处理。有了事件和监听器，剩下的就是发布事件，然后让相应的监听器监听并处理。通常情况，我们会有一个事件发布者，它本身作为事件源，在合适的时机，将相应的事件发布给对应的事件监听器：<img src="/2019/11/05/spring-boot-1/32.png" alt></p><p>对于事件发布者(事件源)通常需要关注两点：</p><p>  1.在合适的时机发布事件。此例中的methodMonitor() 方法是事件发布的源头，其在方法执行之前和结束之后两个时间点发布MethodMonitorEvent事件，每个时间点发布的事件都会传给相应的监听器进行处理。在具体实现时需要注意的是，事件发布是顺序执行，为了不影响处理性能，事件监听器的处理逻辑应尽量简单。</p><p>  2.事件监听器的管理。Publisher类中提供了事件监听器的注册和移除方法，这样客户端可以根据实际情况决定是否需要注册新的监听器或者移除某个监听器。如果这里没有提供remove方法，那么注册的监听器将一直被MethodMonitorEventPublisher引用，即使已经被废弃不用了，也依然在发布者的监听器列表中，这会导致隐性的内存泄漏。</p><p><strong>Spring容器内的事件监听机制</strong></p><p>  Spring的ApplicationContext容器内部中的所有事件类型均继承自 org.springframework.context.ApplicationEvent，容器中的所有监听器都实现 org.spring.framework.context.ApplicationListener接口，并且以bean的形式注册在容器中。一旦在容器内发布ApplicationEvent及其子类型的事件，注册到容器的ApplciationListener就会对这些事件进行处理。</p><p>  最后，如果我们的业务需要在容器内部发布事件，只需要为其注入AplicationEventPublisher依赖即可：实现ApplicationEventPublisherAware 接口或者ApplicationContextAware 接口(Aware接口相关内容请回顾上文)。</p><h3 id="五、出神入化：揭秘自动配置原理"><a href="#五、出神入化：揭秘自动配置原理" class="headerlink" title="五、出神入化：揭秘自动配置原理"></a>五、出神入化：揭秘自动配置原理</h3><p>典型的Spring Boot应用的启动类一般均位于 src/main/java 根路径下，比如 MoonApplication 类：</p><p><img src="/2019/11/05/spring-boot-1/33.png" alt></p><p>其中 @SpringBootApplication 开启组件扫描和自动配置，而SpringApplication.run则负责启动引导程序。@SpringBootApplication是一个复合 Annotation ，它将三个有用的注解组合在一起：<img src="/2019/11/05/spring-boot-1/34.png" alt></p><p>  @SpringBootConfiguration就是@Configuration，它是Spring框架的注解，标明该类是一个 JavaConfig配置类。而 @ComponentScan启用组件扫描，前文已经详细讲过，这里着重关注 @EnableAutoCofiguration。</p><p>  @EnableAutoConfiguration注解表示开启Spring Boot自动配置功能，Spring Boot会根据应用的依赖、自定义的bean、classpath下有没有某个类等等因素来猜测你需要的bean，然后注册到IOC容器中。那@EnableAutoConfiguration是如何推算出你的需求？首先看下他得定义：<img src="/2019/11/05/spring-boot-1/35.png" alt></p><p>  你的关注点应该在 @Import(AutoConfigurationImportSelector.class)上了，前文说过，@Import 注解用于导入类，并且将这个类作为一个bean的定义注册到容器中，并且这个类会将所有符合条件的@Configuration配置都加载到容器中，看看它的代码：<img src="/2019/11/05/spring-boot-1/36.png" alt></p><p>  这个类会扫描所有的jar包，将所有符合条件的@Configuration配置类注入到容器中，何为符合条件，看看 META-INF/spring.factories 的文件内容：<img src="/2019/11/05/spring-boot-1/37.png" alt></p><p>  以DataSourceAutoConfiguration为例，看看Spring Boot是如何自动配置的：<img src="/2019/11/05/spring-boot-1/38.png" alt></p><p>分别说一说：</p><p>  @ConditionalOnClass ({DataSource.class,EmbeddedDatabaseType.class}) ：当ClassPath中存在DataSource或者EmbeddedDatabaseType类时才启用这个配置，否则这个配置将被忽略。</p><p>   @EnableConfigurationProperties(DataSourceProperties.class) ：将DataSource的默认配置类注入到IOC容器中，DataSourceproperties定义为：<img src="/2019/11/05/spring-boot-1/39.png" alt></p><p>   @Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class }) ：导入其他额外的配置，就以 DataSourcePoolMetadataProvidersConfiguration 为例吧：<img src="/2019/11/05/spring-boot-1/40.png" alt></p><p> DataSourcePoolMetadataProvidersConfiguration是数据库连接池提供者的一个配置类，即Classpath中存在 org.apache.tomcat.jdbc.pool.DataSource.class，则使用tomcat-jdbc连接池，如果Classpath中存在 HikariDataSource.class则使用Hikari连接池。 </p><p> 这里仅描述了DataSourceAutoConfiguration的冰山一角，但足以说明Spring Boot如何利用条件话配置来实现自动配置的。回顾一下， @EnableAutoConfiguration中导入了EnableAutoConfigurationImportSelector类，而这个类的 selectImports()通过SpringFactoriesLoader得到了大量的配置类，而每一个配置类则根据条件化配置来做出决策，以实现自动配置。 </p><p> 整个流程很清晰，但漏了一个大问题：  </p><p>  EnableAutoConfigurationImportSelector.selectImports()是何时执行的？其实这个方法会在容器启动过程中执行： AbstractApplicationContext.refresh()，更多的细节在下一小节中说明。 </p><h3 id="六、启动引导：Spring-Boot应用启动的秘密"><a href="#六、启动引导：Spring-Boot应用启动的秘密" class="headerlink" title="六、启动引导：Spring Boot应用启动的秘密"></a>六、启动引导：Spring Boot应用启动的秘密</h3><p><strong>6.1 SpringApplication初始化</strong></p><p>  SpringBoot整个启动流程分为两个步骤：初始化一个SpringApplication对象、执行该对象的run方法。看下SpringApplication的初始化流程，SpringApplication的构造方法中调用initialize(Object[] sources)方法，其代码如下： </p><p><img src="/2019/11/05/spring-boot-1/41.png" alt></p><p>  初始化流程中最重要的就是通过SpringFactoriesLoader找到 spring.factories文件中配置的 ApplicationContextInitializer和 ApplicationListener两个接口的实现类名称，以便后期构造相应的实例。 ApplicationContextInitializer的主要目的是在 ConfigurableApplicationContext做refresh之前，对ConfigurableApplicationContext实例做进一步的设置或处理。ConfigurableApplicationContext继承自ApplicationContext，其主要提供了对ApplicationContext进行设置的能力。 </p><p>  实现一个ApplicationContextInitializer非常简单，因为它只有一个方法，但大多数情况下我们没有必要自定义一个ApplicationContextInitializer，即便是Spring Boot框架，它默认也只是注册了两个实现，毕竟Spring的容器已经非常成熟和稳定，你没有必要来改变它。 </p><p>   而 ApplicationListener的目的就没什么好说的了，它是Spring框架对Java事件监听机制的一种框架实现，具体内容在前文Spring事件监听机制这个小节有详细讲解。这里主要说说，如果你想为Spring Boot应用添加监听器，该如何实现？ </p><p>   Spring Boot提供两种方式来添加自定义监听器： </p><ol><li><p>通过 SpringApplication.addListeners(ApplicationListener&lt;?&gt;…listeners)或者 SpringApplication.setListeners(Collection&lt;?extendsApplicationListener&lt;?&gt;&gt;listeners)两个方法来添加一个或者多个自定义监听器 </p></li><li><p>既然SpringApplication的初始化流程中已经从 spring.factories中获取到 ApplicationListener的实现类，那么我们直接在自己的jar包的 META-INF/spring.factories文件中新增配置即可： <img src="/2019/11/05/spring-boot-1/42.png" alt></p></li></ol><p><strong>6.2  Spring Boot启动流程</strong></p><p>  Spring Boot应用的整个启动流程都封装在SpringApplication.run方法中，其整个流程真的是太长太长了，但本质上就是在Spring容器启动的基础上做了大量的扩展，按照这个思路来看看源码： <img src="/2019/11/05/spring-boot-1/43.png" alt></p><p>① 通过SpringFactoriesLoader查找并加载所有的 SpringApplicationRunListeners，通过调用starting()方法通知      所有的SpringApplicationRunListeners：应用开始启动了。SpringApplicationRunListeners其本质上就是一个事件发布者，它在SpringBoot应用启动的不同时间点发布不同应用事件类型(ApplicationEvent)，如果有哪些事件监听者(ApplicationListener)对这些事件感兴趣，则可以接收并且处理。还记得初始化流程中，SpringApplication加载了一系列ApplicationListener吗？这个启动流程中没有发现有发布事件的代码，其实都已经在SpringApplicationRunListeners这儿实现了。 </p><p>   简单的分析一下其实现流程，首先看下SpringApplicationRunListener的源码：<img src="/2019/11/05/spring-boot-1/44.png" alt> </p><p>  SpringApplicationRunListener只有一个实现类： EventPublishingRunListener。①处的代码只会获取到一个EventPublishingRunListener的实例，我们来看看starting()方法的内容： <img src="/2019/11/05/spring-boot-1/45.png" alt></p><p>   顺着这个逻辑，你可以在②处的 prepareEnvironment()方法的源码中找到 listeners.environmentPrepared(environment);即SpringApplicationRunListener接口的第二个方法，那不出你所料， environmentPrepared()又发布了另外一个事件 ApplicationEnvironmentPreparedEvent。接下来会发生什么，就不用我多说了吧。 </p><p>② 创建并配置当前应用将要使用的 Environment，Environment用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，开发经验丰富的同学对这两个东西一定不会陌生：不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当Environment准备好后，在整个应用的任何时候，都可以从Environment中获取资源。 </p><p>  总结起来，②处的两句代码，主要完成以下几件事： </p><ol><li>判断Environment是否存在，不存在就创建（如果是web项目就创建 StandardServletEnvironment，否则创建 StandardEnvironment） </li><li><p>配置Environment：配置profile以及properties </p></li><li><p>调用SpringApplicationRunListener的 environmentPrepared()方法，通知事件监听者：应用的Environment已经准备好 </p><p>③、SpringBoot应用在启动时会输出这样的东西： <img src="/2019/11/05/spring-boot-1/46.png" alt></p><p>如果想把这个东西改成自己的涂鸦，你可以研究以下Banner的实现，这个任务就留给你们吧。 </p><p>④、根据是否是web项目，来创建不同的ApplicationContext容器。 </p><p>⑤、创建一系列 FailureAnalyzer，创建流程依然是通过SpringFactoriesLoader获取到所有实现FailureAnalyzer接口的class，然后在创建对应的实例。FailureAnalyzer用于分析故障并提供相关诊断信息。 </p><p>⑥、初始化ApplicationContext，主要完成以下工作： </p></li></ol>]]></content>
    
    <summary type="html">
    
      什么是spring boot？ 启动方式、主类及目录结构、starter启动器、核心配置
    
    </summary>
    
      <category term="spring boot" scheme="https://dingding15yd.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="https://dingding15yd.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>简单认识markdown语法</title>
    <link href="https://dingding15yd.github.io/2019/11/04/%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://dingding15yd.github.io/2019/11/04/简单认识markdown语法/</id>
    <published>2019-11-04T06:25:26.000Z</published>
    <updated>2020-01-15T03:36:58.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p><img src="/images/iconfinder_markdown_298823.png" alt></p><p>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>由约翰 格鲁伯 (john Gruber) 于2004年创建。</p><p>可以导出HTML、Word、图像、PDF、Epub等格式文档。</p><p>文档后缀 .md ，.markdown。</p><h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><h4 id="1、使用-和-标记一级和二级标题"><a href="#1、使用-和-标记一级和二级标题" class="headerlink" title="1、使用 = 和 - 标记一级和二级标题"></a>1、使用 = 和 - 标记一级和二级标题</h4><p>​      = 和 -标记语法格式如下：</p><p>​     <img src="/images/微信截图_20191104144807.png" alt></p><p>​      显示效果如下图：</p><p><img src="/images/01986C87-7E19-4497-878E-AE996AFC088E.jpg" alt></p><h4 id="2、使用-号标记"><a href="#2、使用-号标记" class="headerlink" title="2、使用 # 号标记"></a>2、使用 # 号标记</h4><p>​        使用#号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><p><img src="/images/微信截图_20191104145328.png" alt></p><p>​        显示效果如下：</p><p><img src="/images/微信截图_20191104145441.png" alt></p><h1 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h1><p>Markdown 段落没有特殊的格式，直接编辑文字就好，段落的换行是使用两个以上空格加上回车。<img src="/2019/11/04/简单认识markdown语法/1.png" alt></p><p> 当然也可以在段落后使用一个空行来表示重新开始一个段落。<img src="/2019/11/04/简单认识markdown语法/2.png" alt></p><h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><p> 可以使用以下几种字体：<img src="/2019/11/04/简单认识markdown语法/3.png" alt></p><p>效果如下：</p><p><img src="/2019/11/04/简单认识markdown语法/4.png" alt></p><h3 id="3-分隔线"><a href="#3-分隔线" class="headerlink" title="3.分隔线"></a>3.分隔线</h3><p>   用三个以上的星号、减号、底线来表示，符号中间可以有空格。<img src="/2019/11/04/简单认识markdown语法/5.png" alt></p><p>   效果如下：<img src="/2019/11/04/简单认识markdown语法/6.png" alt></p><h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4.删除线"></a>4.删除线</h3><p>​    在文字两端加上~~即可。<img src="/2019/11/04/简单认识markdown语法/7.png" alt></p><p>​    效果如下：</p><p><img src="/2019/11/04/简单认识markdown语法/8.png" alt></p><h3 id="5-下划线"><a href="#5-下划线" class="headerlink" title="5.下划线"></a>5.下划线</h3><p>​      通过HTML的 <u> 标签来实现。<img src="/2019/11/04/简单认识markdown语法/9.png" alt></u></p><p>​      效果如下：     </p><p><img src="/2019/11/04/简单认识markdown语法/10.png" alt></p><h3 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h3><p>​         脚注是对文本的补充说明。<img src="/2019/11/04/简单认识markdown语法/11.png" alt></p><p>​         用法如下：</p><p><img src="/2019/11/04/简单认识markdown语法/12.png" alt></p><p>​        效果如下：</p><p><img src="/2019/11/04/简单认识markdown语法/13.png" alt></p><h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h3><p>​    使用型号 * 、加号 +、或 减号 - 作为标记。<img src="/2019/11/04/简单认识markdown语法/14.png" alt></p><p>​     效果如下：<img src="/2019/11/04/简单认识markdown语法/15.png" alt></p><h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h3><p>​     用数字加上 . 号表示：<img src="/2019/11/04/简单认识markdown语法/16.png" alt></p><p>​     效果如下：<img src="/2019/11/04/简单认识markdown语法/17.png" alt></p><h3 id="3-列表嵌套"><a href="#3-列表嵌套" class="headerlink" title="3.列表嵌套"></a>3.列表嵌套</h3><p>​      列表嵌套只需在子列表中的选项中添加四个空格即可。<img src="/2019/11/04/简单认识markdown语法/18.png" alt></p><p>​     效果如下：</p><p><img src="/2019/11/04/简单认识markdown语法/19.png" alt></p><h1 id="Markdown区块"><a href="#Markdown区块" class="headerlink" title="Markdown区块"></a>Markdown区块</h1><p>在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p>]]></content>
    
    <summary type="html">
    
      markdown语法简单介绍
    
    </summary>
    
      <category term="markdown" scheme="https://dingding15yd.github.io/categories/markdown/"/>
    
    
      <category term="markdown" scheme="https://dingding15yd.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
