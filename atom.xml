<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>橘子先生</title>
  
  <subtitle>我很想记得，可是我记不得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dingding15yd.github.io/"/>
  <updated>2019-11-07T07:35:18.062Z</updated>
  <id>https://dingding15yd.github.io/</id>
  
  <author>
    <name>dingding</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javaa开发路线图 - 2019</title>
    <link href="https://dingding15yd.github.io/2019/11/07/Java%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE-2019/"/>
    <id>https://dingding15yd.github.io/2019/11/07/Java开发路线图-2019/</id>
    <published>2019-11-07T07:27:18.000Z</published>
    <updated>2019-11-07T07:35:18.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Java-8的各项功能"><a href="#1、Java-8的各项功能" class="headerlink" title="1、Java 8的各项功能"></a>1、Java 8的各项功能</h3><p>   Java程序员应该学习并掌握的下一个重要API是Java 8的各项功能。可以毫不夸张地说，这些功能彻底改变了如今Java的编程方式。 </p><p>   因此，作为一名Java开发人员，您不应该错过了解与使用<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247490334&amp;idx=1&amp;sn=45e3daa153a744ada788d2f4de199192&amp;chksm=eb539e28dc24173e66d7fc010ac5c7d4fc6e69cbcc722ecc07df25b3344d63852c0e367f3904&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Lambda</a>表达式、Stream API、<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484481&amp;idx=1&amp;sn=b4a0586ce8c9a798d26a3eb6273ffa5d&amp;chksm=eb538177dc2408613493aa78273683c007427be4b217b41dc8d8b5e36435c398ce937f1af799&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Optional</a>类、以及全新Date and Time API的机会。 </p><p>  Java 8已经发布5年多了，如今大多数库都已停止了支持低于Java 8的版本。因此如果您想顺利地实现Java应用程序的编写与调试的话，请赶快抓紧时间学习Java 8的各项新功能。</p><p>关注微信公众号：Java技术栈，在后台回复：Java，可以获取我整理的 N 篇最新 Java 8－12 新特性教程，都是干货。</p><p><img src="/2019/11/07/Java开发路线图-2019/1.png" alt></p><h3 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h3><p>   测试，尤其是单元测试、集成测试和自动化测试，是任何Java开发人员必修的一项基本技能。其中，JUnit和Mockito是两种被Java开发人员最为熟悉、且欢迎的单元测试和模拟库。</p><p>   当然，您也可以去学习一下更高级的程序库，例如：用于业务驱动测试的Cucumber，用于集成测试的Robot Framework，以及您肯定“绕不开”的JUnit。 </p><p>   在常见的PowerMock、Mockito和EasyMock三种模拟库中，我强烈建议您学习Mockito。由于目前有许多Java开发人员和公司都在使用它，因此它已逐渐成为了在Java中创建模拟对象的标准库。 </p><h3 id="3、实用程序库"><a href="#3、实用程序库" class="headerlink" title="3、实用程序库"></a>3、实用程序库</h3><p>   一直以来，Java都拥有着丰富的开源程序库，它们可以帮助开发人员实现从日志记录到机器学习，从发送HTTP请求到解析JSON等，几乎所有的工作。 </p><p>   值得一提的是：Apache Commons和Google Guava这两个实用程序库，它们是Java JDK库的有效补充。 </p>]]></content>
    
    <summary type="html">
    
      Java 8 、单元测试、实用开源程序库
    
    </summary>
    
      <category term="待学习" scheme="https://dingding15yd.github.io/categories/%E5%BE%85%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dingding15yd.github.io/2019/11/05/spring-boot-1/"/>
    <id>https://dingding15yd.github.io/2019/11/05/spring-boot-1/</id>
    <published>2019-11-05T10:54:52.291Z</published>
    <updated>2019-11-18T07:30:28.588Z</updated>
    
    <content type="html"><![CDATA[<p>title: spring boot - 1<br>date: 2019-11-05 18:54:52<br>category: spring boot<br>tags: spring boot<br>description: 什么是spring boot？ 启动方式、主类及目录结构、starter启动器、核心配置</p><p><img src="/2019/11/05/spring-boot-1/1.png" alt></p><h3 id="Spring-Boot-的背景"><a href="#Spring-Boot-的背景" class="headerlink" title="Spring  Boot 的背景"></a>Spring  Boot 的背景</h3><p>  得益于Spring框架的流行，它的两把利器：IOC 和 AOP，IOC帮助我们管理对象的依赖关系，极大减少对象的耦合性，而AOP的切面编程可以方便使用动态代理来实现各种动态方法功能（如事务、缓存、日志等）。</p><p>  而要集成Spring框架，必须要用到XML配置文件，或者注解式的 Java 代码配置。无论使用XML或者代码配置方式，都需要对相关组件的配置有足够的了解，然后在编写大量冗长的配置代码。</p><h1 id="什么是Spring-Boot？"><a href="#什么是Spring-Boot？" class="headerlink" title="什么是Spring  Boot？"></a>什么是Spring  Boot？</h1><p>​    Spring boot是spring开源组织的子项目，是Srping组件一站式解决方案，简化了Spring的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><p>​    Spring Boot不但能创建传统的 war 包，还能创建独立的不依赖于任何外部容器（如：Tomcat）的独立应用，使用java -jar 命令就能启动。</p><h3 id="Spring-Boot的优点"><a href="#Spring-Boot的优点" class="headerlink" title="Spring  Boot的优点"></a>Spring  Boot的优点</h3><ul><li><p>独立运行</p><p>Spring boot内嵌各种servlet容器，Tomcat、Jetty等，现在不再需要打包成war包部署到容器中，Spring boot只要只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。</p></li><li><p>简化配置</p><p>spring-boot-starter-web启动器自动依赖其他组件，简化了maven配置。</p><p>使用Maven命令：mvn dependency：tree 也可以看到完整的依赖树：<img src="/2019/11/05/spring-boot-1/2.png" alt></p></li><li><p>自动配置</p></li></ul><p>​           spring boot能根据当前类路径下的类、jar包来自动bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。  </p><ul><li><p>无代码生成和XML配置</p><p>spring boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是spring4.x的核心功能之一。</p></li><li><p>应用监控</p><p>spring boot提供一系列端点可以监控服务及应用，做健康检测。</p></li></ul><h3 id="Spring-Boot的缺点"><a href="#Spring-Boot的缺点" class="headerlink" title="Spring Boot的缺点"></a>Spring Boot的缺点</h3><p>  1、Spring boot虽然上手很容易，但需要了解核心技术和流程，所以一旦遇到问题就很棘手，因为什么东西都集成了，自动配置化。这样需要对配置信息非常熟悉，找起问题来不是很容易。</p><p>  2、原始 Spring 项目很难平滑迁移到Spring boot 框架上，因为有些老旧的XML配置无法通过Java来配置，还需要额外的XML文件就不是很完美。还有，之前独立的Tomcat什么参数都在线上配置好了，改为内置的Tomcat就会遇到很多问题。</p><h1 id="Spring-Boot的四大核心特性"><a href="#Spring-Boot的四大核心特性" class="headerlink" title="Spring  Boot的四大核心特性"></a>Spring  Boot的四大核心特性</h1><p>  spring boot最重要的四大核心特性是 自动配置、起步依赖、Actuator、命令行界面(CLI)。其中CLI是Spring boot 的可选特性，虽然它功能强大，但也引入一套不太常规的开发模型，因此不做详解。</p><h3 id="一、抛砖引玉：Spring-IOC容器"><a href="#一、抛砖引玉：Spring-IOC容器" class="headerlink" title="一、抛砖引玉：Spring IOC容器"></a>一、抛砖引玉：Spring IOC容器</h3><p>  SpringApplication 启动类是对一个典型的Spring应用的启动流程进行了扩展，因此，彻底理解Spring容器是打开Spring Boot大门的一把钥匙。</p><h3 id="1-1、Spring-IOC容器"><a href="#1-1、Spring-IOC容器" class="headerlink" title="1.1、Spring IOC容器"></a>1.1、Spring IOC容器</h3><p>​    把spring ioc容器比作一间餐馆，当你来到餐馆，通常会直接招呼服务员：点菜！至于菜的原料是什么？如何用原料把菜做出来？who care。ioc 容器也是一样的，你告诉他需要哪个bean，他就把相应的实例（instance）扔给你，至于这个bean是否依赖其他组件，怎么完成初始化，根本不需要你的关心。</p><p>  作为餐馆，想要做出菜肴，得知道菜的原料和菜谱，同样的，IOC容器想要管理各个业务对象以及它们之间的依赖关系，需要通过某种途径来记录和管理这些信息。 BeanDefinition 对象就承担了这个责任：容器中的每一个bean都会有一个对应的BeanDefinition实例，该实例负责保存bean对象的所有必要信息，包括bena对象的class类型、是否是抽象类、构造方法和参数、其他属性等。当客户端向容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的bean实例。</p><p>  原材料已经准备好（把BeanDefinition看成原料），开始做菜吧，等等，你还需要一份菜谱，而BeanDefinitionRegistry 和 BeanFactory就是这本菜谱，BeanDefinitionRegistry 抽象出bean的注册逻辑，而BeanFactory则抽象出了bean的管理逻辑，而各个BeanFactory的实现类就具体承担了bean的注册以及管理工作。他们之间的关系如下图：<img src="/2019/11/05/spring-boot-1/3.jpg" alt></p><p>  DefaultListableBeanFactory作为一个比较通用的BenaFactory实现、它同时也实现了BeanDefinitionRegistry接口，因此它就承担了Bean的注册管理工作。从图中也可以看出，BeanFactory接口中主要包括getBean、containBean、getType、getAliases等管理bean的方法，而BeanDefinitionRegistry接口则包括registerBeanDefinition、removeBeanDefinition、getBeanDedinition等注册管理BeanDefinition的方法。</p><p>  下面通过一段简单的代码来模拟BeanFactory底层是如何工作的：<img src="/2019/11/05/spring-boot-1/4.png" alt></p><p>  这段代码仅为说明BeanFactory底层的大致工作流程，实际会更复杂，比如bean之间的依赖关系可能定义在外部配置文件（XML/Properties）中、也可能是注解方式。Spring Ioc容器的整个工作流程大致可以分为两个阶段：</p><blockquote><p>1.容器启动阶段</p></blockquote><p>  容器启动时，会通过某种途径加载ConfigurationMetaData。除了代码方式比较直接外，在大部分情况下，容器需要依赖某些工具类，比如BeanDefinitionReader，BeanDefinitionReader会对加载的ConfigurationMetaData进行解析和分析，并将分析后的信息组装为相应的BeanDefinition，最后把这些保存了bean定义的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器的启动工作就完成了。这个阶段主要完成一些准备性工作，更侧重于bean对象管理信息的收集，当然一些验证性或辅助性的工作也在这一阶段完成。</p><p>看一个简单例子，以前，所有的bean都定义在XML配置文件中，下面的代码将模拟BeanFactory如何从配置文件中加载bean的定义以及依赖关系：<img src="/2019/11/05/spring-boot-1/5.png" alt></p><blockquote><p>2.Bean的实例化阶段</p></blockquote><p>  经过第一个阶段，所有bean定义都通过BeanDefinition的方式注册到BeanDefinitionRegistry中，当某个请求通过容器的getBean方法请求某个对象，或者因为依赖关系容器需要隐式的调用getBean时，就会触发第二阶段的活动，容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完成后，容器会立刻将其返回给请求方法使用。</p><p>  BeanFactory只是Spring Ioc容器的一种实现，如果没有特殊指定，它采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。而在实际场景下，我们更多的使用另外一种类型的容器：ApplicationContext，它构建在BeanFactory之上，属于更高级的容器，除了具有BeanFactory的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的bean，在容器启动时全部完成初始化和依赖注入操作。</p><h3 id="1-2、Spring容器扩展机制"><a href="#1-2、Spring容器扩展机制" class="headerlink" title="1.2、Spring容器扩展机制"></a>1.2、Spring容器扩展机制</h3><p>  IoC容器负责管理容器中所有bean的生命周期，而在bean生命周期的不同阶段，Spring提供了不同的扩展点来改变bean的命运。在容器的启动阶段，BeanFactoryPostProcessor允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做一些额外的操作，比如修改bean定义的某些属性或者增加其它信息等。</p><p>  如果要自定义扩展类，通常需要实现 org.springframework.beans.factory.config.BeanFactoryPostProcessor接口，与此同时，因为容器中可能有多个BeanFactoryPostProcessor，可能还需要实现 org.springframework.core.Ordered接口，以保证BeanFactoryPostProcessor按照顺序执行。Spring 提供了为数不多的BeanFactoryPostProcessor实现，我们以PropertryPlaceholderConfigurer来说明大致工作流程。</p><p>  在Spring项目的XML配置文件中，经常可以看到许多配置项的值使用占位符，而将占位符所代表的值单独配置到独立的 properties 文件中，这样可以将散落在不同XML文件中的配置集中管理，而且也方便运维根据不同的环境进行匹配不同的值。这个非常实用的功能就是由 PropertyPlaceholderConfigurer负责实现的。</p><p>  根据前文，当BeanFactory在第一阶段加载完所有配置信息时，BeanFactory中保存的对象的属性还是以占位符方式存在的，比如 ${jdbc.mysql.url}。当 PropertyPlaceholderConfigurer 作为BeanFactoryProcessor被应用时，它会使用properties配置文件中的值来替换相应的BeanDefinition中占位符所表示的属性值。当需要实例化bean时，bean定义中的属性值就已经被替换我们配置的值。当然其实现比上面描述的要复杂一些，这里仅说明其大致工作原理，更详细的实现可以参考源码。</p><p>  与之相似的，还有BeanPostProcessor，其存在于对象实例化阶段。跟BeanFactoryPostProcessor类似，它会处理容器内所有符合条件并且已经实例化后的对象。简单的对比，BeanFactoryPostProcessor处理bean的定义，而BeanPostProcessor则处理bean完成实例化后的对象。BeanPostProcessor定义了两个接口：<img src="/2019/11/05/spring-boot-1/6.png" alt></p><p>  为了理解这两个方法执行的时机，简单了解bean的整个生命周期：(Bean的实例化过程)<img src="/2019/11/05/spring-boot-1/7.png" alt></p><p>  postProcessBeforeInitialization()方法与postProcessAfterInitialization()分别对应图中前置处理和后置处理两个步骤将执行的方法。这两个方法中都传入了bean对象实例的引用，为扩展容器的对象实例化过程提供了很大便利，在这几乎可以对传入的实例执行任何操作。注解、AOP等功能的实现均大量使用了 BeanPostProcessor，比如有一个自定义注解，你完全可以实现 BeanPostProcessor 的接口，在其中判断bean对象的脑袋上是否有该注解，如果有，你可以对这个bean实例执行任何操作，想想是不是非常简单？</p><p>  再来看一个更常见的例子，在Spring中经常能看到各种各样的Aware接口，其作用就是在对象实例化完成后将Aware接口中规定的依赖注入到当前实例中。比如最常见的ApplicationContextAware接口，实现了这个接口的类都可以获得一个ApplicationContext对象。当容器中 每个对象的实例化过程走到BeanPostProcessor前置处理这一步时，容器会检测到之前注册到容器的ApplicationContextAwareProcessor，然后就会调用其postProcessBeforeInitialization()方法，检查并设置Aware相关依赖。看看代码吧，是不是很简单： <img src="/2019/11/05/spring-boot-1/8.png" alt></p><h3 id="二、夯实基础：JavaConfig与常见Annotation"><a href="#二、夯实基础：JavaConfig与常见Annotation" class="headerlink" title="二、夯实基础：JavaConfig与常见Annotation"></a>二、夯实基础：JavaConfig与常见Annotation</h3><h4 id="2-1、javaconfig"><a href="#2-1、javaconfig" class="headerlink" title="2.1、javaconfig"></a>2.1、javaconfig</h4><p>   我们知道 bean是Spring IOC中非常核心的概念，Spring容器负责bean的生命周期的管理。在最初，Spring使用XML配置文件的方式来描述bean的定义以及相互间的依赖关系，但随着Spring的发展，越来越多的人对这种方式表示不满，因为Spring项目的所有业务类均以bean的形式配置在XML文件中，造成了大量的XML文件，使项目变得复杂且难以管理。 </p><p>   后来，基于纯Java Annotation依赖注入框架 Guice出世，其性能明显优于采用XML方式的Spring，甚至有部分人认为， Guice可以完全取代Spring（ Guice仅是一个轻量级IOC框架，取代Spring还差的挺远）。正是这样的危机感，促使Spring及社区推出并持续完善了 JavaConfig子项目，它基于Java代码和Annotation注解来描述bean之间的依赖绑定关系。比如，下面是使用XML配置方式来描述bean的定义： <img src="/2019/11/05/spring-boot-1/9.png" alt></p><p>  而基于JavaConfig的配置形式是这样的：<img src="/2019/11/05/spring-boot-1/10.png" alt></p><p>   如果两个bean之间有依赖关系的话，在XML配置中应该是这样： <img src="/2019/11/05/spring-boot-1/11.png" alt></p><p>   而在JavaConfig中则是这样： <img src="/2019/11/05/spring-boot-1/12.png" alt></p><p>   你可能注意到这个示例中，有两个bean都依赖于dependencyService，也就是说当初始化bookService时会调用 dependencyService()，在初始化otherService时也会调用 dependencyService()，那么问题来了？这时候IOC容器中是有一个dependencyService实例还是两个？这个问题留着大家思考吧，这里不再赘述。 </p><h4 id="2-2、-ComponentScan"><a href="#2-2、-ComponentScan" class="headerlink" title="2.2、@ComponentScan"></a>2.2、@ComponentScan</h4><p>   @ComponentScan 注解对应XML配置形式中的 <a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>元素，表示启用组件扫描，Spring会自动扫描所有通过注解配置的bean，然后将其注册到IOC容器中，我们可以通过 basePackages 等属性来指定 @ComponentScan 自动扫描的范围，如果不指定，默认从声明@ComponentScan所在类的package进行扫描。正因为如此，SpringBoot的启动类都默认在 src/main/java 下。</p><h4 id="2-3、-Import"><a href="#2-3、-Import" class="headerlink" title="2.3、@Import"></a>2.3、@Import</h4><p>  @Import注解用于导入配置类，举个简单的例子：<img src="/2019/11/05/spring-boot-1/13.png" alt></p><p>   现在有另外一个配置类，比如： MoonUserConfiguration，这个配置类中有一个bean依赖于MoonBookConfiguration中的bookService，如何将这两个bean组合在一起？借助 @Import即可： <img src="/2019/11/05/spring-boot-1/14.png" alt></p><p>   需要注意的是，在4.2之前， @Import注解只支持导入配置类，但是在4.2之后，它支持导入普通类，并将这个类作为一个bean的定义注册到IOC容器中。 </p><h4 id="2-4、-Conditional"><a href="#2-4、-Conditional" class="headerlink" title="2.4、@Conditional"></a>2.4、@Conditional</h4><p>   @Conditional注解表示在满足某种条件后才初始化一个bean或者启用某些配置。它一般用在由 @Component、 @Service、 @Configuration等注解标识的类上面，或者由 @Bean标记的方法上。如果一个 @Configuration类标记了 @Conditional，则该类中所有标识了 @Bean的方法和 @Import注解导入的相关类将遵从这些条件。 </p><p>   在Spring里可以很方便的编写你自己的条件类，所要做的就是实现 Condition接口，并覆盖它的 matches()方法。举个例子，下面的简单条件类表示只有在 Classpath里存在 JdbcTemplate类时才生效： <img src="/2019/11/05/spring-boot-1/15.png" alt></p><p>   当你用Java来声明bean的时候，可以使用这个自定义条件类： <img src="/2019/11/05/spring-boot-1/16.png" alt></p><p>   这个例子中只有当 JdbcTemplateCondition类的条件成立时才会创建MyService这个bean。也就是说MyService这bean的创建条件是 classpath里面包含 JdbcTemplate，否则这个bean的声明就会被忽略掉。 </p><p>  SpringBoot定义了很多有趣的条件，并把他们运用到了配置类上，这些配置类构成了 SpringBoot的自动配置的基础。 SpringBoot运用条件化配置的方法是：定义多个特殊的条件化注解，并将它们用到配置类上。下面列出了 SpringBoot提供的部分条件化注解：<img src="/2019/11/05/spring-boot-1/17.png" alt></p><p>2.5、@ConfigurationProperties 与 @EnableConfigurationProperties</p><p>   当某些属性的值需要配置的时候，我们一般会在 application.properties文件中新建配置项，然后在bean中使用 @Value注解来获取配置的值，比如下面配置数据源的代码。 <img src="/2019/11/05/spring-boot-1/18.png" alt></p><p>   使用 @Value注解注入的属性通常都比较简单，如果同一个配置在多个地方使用，也存在不方便维护的问题（考虑下，如果有几十个地方在使用某个配置，而现在你想改下名字，你改怎么做？）。对于更为复杂的配置，Spring Boot提供了更优雅的实现方式，那就是 @ConfigurationProperties注解。我们可以通过下面的方式来改写上面的代码：</p><p> <img src="/2019/11/05/spring-boot-1/19.png" alt></p><p>   @ConfigurationProperties对于更为复杂的配置，处理起来也是得心应手，比如有如下配置文件： <img src="/2019/11/05/spring-boot-1/20.png" alt></p><p>   可以定义如下配置类来接收这些属性 <img src="/2019/11/05/spring-boot-1/21.png" alt></p><p>   @EnableConfigurationProperties注解表示对 @ConfigurationProperties的内嵌支持，默认会将对应Properties Class作为bean注入的IOC容器中，即在相应的Properties类上不用加 @Component注解。 </p><p>   《<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247486895&amp;idx=2&amp;sn=1d49a0de72f9dee2c434ae905d5bc2e4&amp;chksm=eb538899dc24018ffb0e618abfe7e2223da20e5b8a2d5be36267769779a82701699cd5476748&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 配置加载顺序详解</a>》了解一下。 </p><h3 id="三、削铁如泥：SpringFactoriesLoader详解"><a href="#三、削铁如泥：SpringFactoriesLoader详解" class="headerlink" title="三、削铁如泥：SpringFactoriesLoader详解"></a>三、削铁如泥：SpringFactoriesLoader详解</h3><p>  JVM提供了3种类加载器：BootstrapClassLoader、ExtClassLoader、AppClassLoader分别加载 Java核心类库、扩展类库以及应用的类路径(CLASSPATH)下的类库。JVM通过双亲委派模型进行类的加载，我们也可以通过继承 java.lang.classloader实现自己的类加载器。</p><p>  何为双亲委派模型？当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的BootstrapClassLoader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。<img src="/2019/11/05/spring-boot-1/22.png" alt></p><p>  采用双亲委派模型的一个好处是保证不同类加载器最终得到的都是一个对象，这样就可以保证 Java 核心库的类型安全，比如，加载位于rt.jar包中的java.lang.Object类，不管是哪个加载器加载这个类，最终都是委托给顶层的BootStrapClassLoader来加载的，这样就可以保证任何的类加载器最终得到的都是同样一个Object对象。查看ClassLoader的源码，对双亲委派模型会更有直观的认识：<img src="/2019/11/05/spring-boot-1/23.png" alt></p><p>  但双亲委派模型并不能解决所有的类加载器问题，比如，Java提供了很多服务提供者接口（ServiceProviderProviderInterface，SPI），允许第三方为这些接口提供实现。常见的SPI有JDBC、JNDI、JAXP等，这些SPI的接口有核心类库提供，却由第三方实现，这样就存在一个问题：SPI的接口是Java核心库的一部分，是由BootStrapClassLoader来加载的。BootStrapClassLoader是无法找到SPI的实现类的，因为它只加载Java的核心库，他也不能代理给AppClassLoader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题。</p><p>  线程上下文类加载器（ContextClassLoader）正好解决了这个问题。从名称上来看，可能会误解为它是一种新的类加载器，实际上，它仅仅是Thread类的一个变量而已，可以通过setContextClassLoader（ClassLoader）和 getContextClassLoader（）来设置和获取该对象。如果不做任何的设置，Java应用的线程的上下文类加载器就是AppClassLoader。在核心类库使用SPI接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到SPI实现的类。线程上下文类加载器在很多SPI的实现中都会用到。但在JDBC中，你可能会看到一种更直接的实现方式，比如，JDBC驱动管理java.sql.Driver中的loadInitialDrivers()方法中，你可以直接看到JDK是如何加载驱动的：</p><p>  <img src="/2019/11/05/spring-boot-1/24.png" alt></p><p>  其实讲解线程上下文类加载器，最主要的是在看到 Thread.currentThread().getClassLoader() 和 Thread.currentThread().getContextClassLoader() 时不会一脸懵逼，这两者除了在许多底层框架中取得的ClassLoader可能会有所不同外，其他大多数业务场景下都是一样的，大家只要知道它是为了解决什么问题存在的即可。</p>  <font color="gree">类加载器除了加载class外，还有一个非常重要的功能，就是加载资源，它可以从jar包中读取任何资源</font>，比如，ClassLoader.getResource(String name) 就是用于读取jar包中的资源文件，其代码如下：<img src="/2019/11/05/spring-boot-1/25.png" alt><br><br>  它的逻辑其实和类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到BootStrapClassLoader，最后才轮到自己查找。<font color="skyblue">而不同的类加载器负责扫描不同路径下的jar包，就如同加载class一样，最后会扫描所有的jar包，找到符合条件的资源文件。</font><p>  类加载器的 findResource(name) 会遍历其负责加载的所有jar包，找到jar包中名称为name的资源文件，这里的资源可以是任何资源，甚至是.class文件，比如下面的示例，用于查找 Array.class 文件：<img src="/2019/11/05/spring-boot-1/26.png" alt></p><p>  运行后得到如下结果：<img src="/2019/11/05/spring-boot-1/27.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;title: spring boot - 1&lt;br&gt;date: 2019-11-05 18:54:52&lt;br&gt;category: spring boot&lt;br&gt;tags: spring boot&lt;br&gt;description: 什么是spring boot？ 启动方式、主类
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单认识markdown语法</title>
    <link href="https://dingding15yd.github.io/2019/11/04/%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://dingding15yd.github.io/2019/11/04/简单认识markdown语法/</id>
    <published>2019-11-04T06:25:26.000Z</published>
    <updated>2019-11-05T09:52:31.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p><img src="/images/iconfinder_markdown_298823.png" alt></p><p>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>由约翰 格鲁伯 (john Gruber) 于2004年创建。</p><p>可以导出HTML、Word、图像、PDF、Epub等格式文档。</p><p>文档后缀 .md ，.markdown。</p><h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><h4 id="1、使用-和-标记一级和二级标题"><a href="#1、使用-和-标记一级和二级标题" class="headerlink" title="1、使用 = 和 - 标记一级和二级标题"></a>1、使用 = 和 - 标记一级和二级标题</h4><p>​      = 和 -标记语法格式如下：</p><p>​     <img src="/images/微信截图_20191104144807.png" alt></p><p>​      显示效果如下图：</p><p><img src="/images/01986C87-7E19-4497-878E-AE996AFC088E.jpg" alt></p><h4 id="2、使用-号标记"><a href="#2、使用-号标记" class="headerlink" title="2、使用 # 号标记"></a>2、使用 # 号标记</h4><p>​        使用#号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><p><img src="/images/微信截图_20191104145328.png" alt></p><p>​        显示效果如下：</p><p><img src="/images/微信截图_20191104145441.png" alt></p><h1 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h1><p>Markdown 段落没有特殊的格式，直接编辑文字就好，段落的换行是使用两个以上空格加上回车。<img src="/2019/11/04/简单认识markdown语法/1.png" alt></p><p> 当然也可以在段落后使用一个空行来表示重新开始一个段落。<img src="/2019/11/04/简单认识markdown语法/2.png" alt></p><h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><p> 可以使用以下几种字体：<img src="/2019/11/04/简单认识markdown语法/3.png" alt></p><p>效果如下：</p><p><img src="/2019/11/04/简单认识markdown语法/4.png" alt></p><h3 id="3-分隔线"><a href="#3-分隔线" class="headerlink" title="3.分隔线"></a>3.分隔线</h3><p>   用三个以上的星号、减号、底线来表示，符号中间可以有空格。<img src="/2019/11/04/简单认识markdown语法/5.png" alt></p><p>   效果如下：<img src="/2019/11/04/简单认识markdown语法/6.png" alt></p><h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4.删除线"></a>4.删除线</h3><p>​    在文字两端加上~~即可。<img src="/2019/11/04/简单认识markdown语法/7.png" alt></p><p>​    效果如下：</p><p><img src="/2019/11/04/简单认识markdown语法/8.png" alt></p><h3 id="5-下划线"><a href="#5-下划线" class="headerlink" title="5.下划线"></a>5.下划线</h3><p>​      通过HTML的 <u> 标签来实现。<img src="/2019/11/04/简单认识markdown语法/9.png" alt></u></p><p>​      效果如下：     </p><p><img src="/2019/11/04/简单认识markdown语法/10.png" alt></p><h3 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h3><p>​         脚注是对文本的补充说明。<img src="/2019/11/04/简单认识markdown语法/11.png" alt></p><p>​         用法如下：</p><p><img src="/2019/11/04/简单认识markdown语法/12.png" alt></p><p>​        效果如下：</p><p><img src="/2019/11/04/简单认识markdown语法/13.png" alt></p><h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h3><p>​    使用型号 * 、加号 +、或 减号 - 作为标记。<img src="/2019/11/04/简单认识markdown语法/14.png" alt></p><p>​     效果如下：<img src="/2019/11/04/简单认识markdown语法/15.png" alt></p><h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h3><p>​     用数字加上 . 号表示：<img src="/2019/11/04/简单认识markdown语法/16.png" alt></p><p>​     效果如下：<img src="/2019/11/04/简单认识markdown语法/17.png" alt></p><h3 id="3-列表嵌套"><a href="#3-列表嵌套" class="headerlink" title="3.列表嵌套"></a>3.列表嵌套</h3><p>​      列表嵌套只需在子列表中的选项中添加四个空格即可。<img src="/2019/11/04/简单认识markdown语法/18.png" alt></p><p>​     效果如下：</p><p><img src="/2019/11/04/简单认识markdown语法/19.png" alt></p><h1 id="Markdown区块"><a href="#Markdown区块" class="headerlink" title="Markdown区块"></a>Markdown区块</h1><p>在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p>]]></content>
    
    <summary type="html">
    
      markdown语法简单介绍
    
    </summary>
    
      <category term="markdown" scheme="https://dingding15yd.github.io/categories/markdown/"/>
    
    
      <category term="markdown" scheme="https://dingding15yd.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>我的尝试</title>
    <link href="https://dingding15yd.github.io/2019/02/26/%E6%88%91%E7%9A%84%E5%B0%9D%E8%AF%95/"/>
    <id>https://dingding15yd.github.io/2019/02/26/我的尝试/</id>
    <published>2019-02-26T04:26:25.000Z</published>
    <updated>2019-11-05T01:35:29.239Z</updated>
    
    <content type="html"><![CDATA[<p>1、首先要明确什么是拦截器、什么是过滤器<br>1.1 什么是拦截器：<br>拦截器，在<a href="https://www.baidu.com/s?wd=AOP&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">AOP</a>（Aspect-Oriented Programming）中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。<br>在Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行。同时也是提供了一种可以提取action中可重用的部分的方式。<br>谈到拦截器，还有一个词大家应该知道——拦截器链（Interceptor Chain，在Struts 2中称为拦截器栈 Interceptor Stack）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。<br>1.2. 拦截器的实现原理：<br>大部分时候，拦截器方法都是通过代理的方式来调用的。Struts 2的拦截器实现相对简单。当请求到达Struts 2的ServletDispatcher时，Struts 2会查找配置文件，并根据其配置实例化相对的拦截器对象，然后串成一个列表（list），最后一个一个地调用列表中的拦截器。<br>1.3 什么是过滤器<br>过滤器是一个程序，它先于与之相关的servlet或<a href="https://www.baidu.com/s?wd=JSP&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">JSP</a>页面运行在服务器上。过滤器可附加到一个或多个servlet或JSP页面上，并且可以检查进入这些资源的请求信息。在这之后，过滤器可以作如下的选择：<br>①以常规的方式调用资源（即，调用servlet或JSP页面）。<br>②利用修改过的请求信息调用资源。<br>③调用资源，但在发送响应到<a href="https://www.baidu.com/s?wd=%E5%AE%A2%E6%88%B7%E6%9C%BA&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">客户机</a>前对其进行修改。<br>④阻止该资源调用，代之以转到其他的资源，返回一个特定的状态代码或生成替换输出。</p><p>1.4 Servlet过滤器的基本原理<br>在Servlet作为过滤器使用时，它可以对客户的请求进行处理。处理完成后，它会交给下一个过滤器处理，这样，客户的请求在过滤链里逐个处理，直到请求发送到目标为止。例如，某网站里有提交“修改的注册信息”的网页，当用户填写完修改信息并提交后，服务器在进行处理时需要做两项工作：判断客户端的会话是否有效；对提交的数据进行统一编码。这两项工作可以在由两个过滤器组成的过滤链里进行处理。当过滤器处理成功后，把提交的数据发送到最终目标；如果过滤器处理不成功，将把视图派发到指定的错误页面。</p><p>2、拦截器与过滤器的区别 ：</p><ol><li>拦截器是基于java的<a href="https://www.baidu.com/s?wd=%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">反射机制</a>的，而过滤器是基于<a href="https://www.baidu.com/s?wd=%E5%87%BD%E6%95%B0&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">函数</a><a href="https://www.baidu.com/s?wd=%E5%9B%9E%E8%B0%83&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">回调</a>。</li><li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li><li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li><li>拦截器可以访问action<a href="https://www.baidu.com/s?wd=%E4%B8%8A%E4%B8%8B%E6%96%87&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">上下文</a>、值栈里的对象，而过滤器不能访问。</li><li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器<a href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">初始化</a>时被调用一次</li></ol><p>拦截器的代码实现(以<a href="https://www.baidu.com/s?wd=struts2&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">struts2</a>为例)：<br>1、在xml文件中如何定义拦截器</p><interceptors><br><interceptor name="filterIPInterceptor" class="com.xxxx.web.FilterIPActionInterceptor"><br><interceptor-stack name="filterIPStack"><br><interceptor-ref name="defaultStack"><br><br><interceptor-ref name="filterIPInterceptor"><br></interceptor-ref></interceptor-ref></interceptor-stack><br></interceptor></interceptors><p>2、怎么遍别写自定义拦截器</p><p>public class FilterIPActionInterceptor extends AbstractInterceptor<br>{<br>/*<em> 日志控制. </em>/<br>private final Log log = LogFactory.getLog(getClass());</p><p>/**</p><ul><li>@see com.opensymphony.xwork2.interceptor.AbstractInterceptor#intercept(com.opensymphony.xwork2.ActionInvocation)<br>*/<br>@Override<br>@SuppressWarnings(“unchecked”)<br>public String intercept(ActionInvocation invocation) throws Exception<br>{<br>String result = null;<br>// 获得当前方法名.<br>String methodName = invocation.getInvocationContext().getName();<br>String currIp = null;<br>try<br>{<br>if (invocation.getAction() instanceof PortletAction)<br>{<br>PortletAction action = (PortletAction) invocation.getAction();<br>currIp = action.getRequest().getRemoteAddr();<br>}<br>String ip = ApplicationResource.getHotValue(“ALLOW_CACHE_IP”);</li></ul><p>if (StringUtils.isBlank(ip) || StringUtils.isBlank(currIp))<br>{<br>log.error(“允许刷新的IP不存在或当前请求的IP非法.”);<br>throw new NoAllowIPException();<br>}<br>else<br>{<br>String[] ips = ip.split(“,”);<br>boolean errorIp = true;<br>for (String s : ips)<br>{<br>if (s.equals(currIp))<br>errorIp = false;<br>}<br>// 判断IP<br>if (errorIp)<br>throw new NoAllowIPException();<br>}<br>result = invocation.invoke();//调用被拦截的方法<br>}<br>catch (Exception e)<br>{<br>log.error(“异常类名:” + invocation.getAction().getClass());<br>log.error(“异常方法:” + methodName, e);<br>throw e;<br>}</p><p>return result;<br>}</p><p>}</p><p>3、怎么编写过滤器</p><p>1、在web.xml里面配置自定义的拦截器</p><filter><br><filter-name>Redirect Filter</filter-name><br><filter-class>com.xx.filter.RedirectFilter</filter-class><br></filter><p><filter-mapping></filter-mapping></p><p><filter-name>Redirect Filter</filter-name></p><p><url-pattern>/xx/xx/*</url-pattern></p><p></p><p>2、如何编写自定义的拦截器<br>public class RedirectFilter implements Filter {<br>public void doFilter(ServletRequest request, ServletResponse response,<br>FilterChain filterChain) throws IOException, ServletException {<br>// 获取URL<br>Long startTime = null;<br>if (log.isDebugEnabled())<br>{<br>startTime = System.currentTimeMillis();<br>}<br>HttpServletRequest httpRequest = (HttpServletRequest) request;<br>String url = httpRequest.getRequestURL().toString();<br>if (url == null || url.trim().length() == 0) {<br>return;<br>}<br>if (url.indexOf(luceneCreateMapping) != -1<br>|| url.indexOf(luceneSearchMapping) != -1) {<br>doFilterForxxx(request, response, url);<br>} else {<br>doxxxx(request, response, url);<br>}<br>if (log.isDebugEnabled())<br>{<br>long endTime = System.currentTimeMillis();<br>Thread currentThread = Thread.currentThread();<br>String threadName = currentThread.getName();<br>log.debug(“[“ + threadName + “]” + “&lt; “</p><ul><li>this.getClass().getName() + “ “ + url + “ “</li><li>(endTime - startTime) + “ ms”);<br>}<br>// 激活下一个Filter<br>filterChain.doFilter(request, response);</li></ul><p>}<br>}</p>]]></content>
    
    <summary type="html">
    
      这是简介
    
    </summary>
    
      <category term="java-基础" scheme="https://dingding15yd.github.io/categories/java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://dingding15yd.github.io/tags/java/"/>
    
  </entry>
  
</feed>
