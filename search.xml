<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>简单认识markdown语法</title>
    <url>/2019/11/04/%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p><img src="/.io//hexo\myblog\source\_posts\简单认识markdown语法\iconfinder_markdown_298823.png" alt> </p>
<p>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>由约翰 格鲁伯 (john Gruber) 于2004年创建。</p>
<p>可以导出HTML、Word、图像、PDF、Epub等格式文档。</p>
<p>文档后缀 .md ，.markdown。</p>
<h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><h4 id="1、使用-和-标记一级和二级标题"><a href="#1、使用-和-标记一级和二级标题" class="headerlink" title="1、使用 = 和 - 标记一级和二级标题"></a>1、使用 = 和 - 标记一级和二级标题</h4><p>​      = 和 -标记语法格式如下：</p>
<p>​     <img src="/.io//hexo\myblog\source\_posts\简单认识markdown语法\微信截图_20191104144807.png" alt></p>
<p>   显示效果如下图：</p>
<p><img src="/.io//hexo\myblog\source\_posts\简单认识markdown语法\01986C87-7E19-4497-878E-AE996AFC088E.jpg" alt></p>
<h4 id="2、使用-号标记"><a href="#2、使用-号标记" class="headerlink" title="2、使用 # 号标记"></a>2、使用 # 号标记</h4><p>​        使用#号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p>
<p><img src="/.io//hexo\myblog\source\_posts\简单认识markdown语法\微信截图_20191104145328.png" alt></p>
<p>显示效果如下：</p>
<p><img src="/.io//hexo\myblog\source\_posts\简单认识markdown语法\微信截图_20191104145441.png" alt></p>
<h1 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h1><p>Markdown 段落没有特殊的格式，直接编辑文字就好，段落的换行是使用两个以上空格加上回车</p>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>读过的书-2019</title>
    <url>/2019/11/04/%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6-2019/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>我的尝试</title>
    <url>/2019/02/26/%E6%88%91%E7%9A%84%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<p>1、首先要明确什么是拦截器、什么是过滤器<br>1.1 什么是拦截器：<br>拦截器，在<a href="https://www.baidu.com/s?wd=AOP&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">AOP</a>（Aspect-Oriented Programming）中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。<br>在Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行。同时也是提供了一种可以提取action中可重用的部分的方式。<br>谈到拦截器，还有一个词大家应该知道——拦截器链（Interceptor Chain，在Struts 2中称为拦截器栈 Interceptor Stack）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。<br>1.2. 拦截器的实现原理：<br>大部分时候，拦截器方法都是通过代理的方式来调用的。Struts 2的拦截器实现相对简单。当请求到达Struts 2的ServletDispatcher时，Struts 2会查找配置文件，并根据其配置实例化相对的拦截器对象，然后串成一个列表（list），最后一个一个地调用列表中的拦截器。<br>1.3 什么是过滤器<br>过滤器是一个程序，它先于与之相关的servlet或<a href="https://www.baidu.com/s?wd=JSP&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">JSP</a>页面运行在服务器上。过滤器可附加到一个或多个servlet或JSP页面上，并且可以检查进入这些资源的请求信息。在这之后，过滤器可以作如下的选择：<br>①以常规的方式调用资源（即，调用servlet或JSP页面）。<br>②利用修改过的请求信息调用资源。<br>③调用资源，但在发送响应到<a href="https://www.baidu.com/s?wd=%E5%AE%A2%E6%88%B7%E6%9C%BA&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">客户机</a>前对其进行修改。<br>④阻止该资源调用，代之以转到其他的资源，返回一个特定的状态代码或生成替换输出。</p>
<p>1.4 Servlet过滤器的基本原理<br>在Servlet作为过滤器使用时，它可以对客户的请求进行处理。处理完成后，它会交给下一个过滤器处理，这样，客户的请求在过滤链里逐个处理，直到请求发送到目标为止。例如，某网站里有提交“修改的注册信息”的网页，当用户填写完修改信息并提交后，服务器在进行处理时需要做两项工作：判断客户端的会话是否有效；对提交的数据进行统一编码。这两项工作可以在由两个过滤器组成的过滤链里进行处理。当过滤器处理成功后，把提交的数据发送到最终目标；如果过滤器处理不成功，将把视图派发到指定的错误页面。</p>
<p>2、拦截器与过滤器的区别 ：</p>
<ol>
<li>拦截器是基于java的<a href="https://www.baidu.com/s?wd=%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">反射机制</a>的，而过滤器是基于<a href="https://www.baidu.com/s?wd=%E5%87%BD%E6%95%B0&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">函数</a><a href="https://www.baidu.com/s?wd=%E5%9B%9E%E8%B0%83&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">回调</a>。</li>
<li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li>
<li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li>
<li>拦截器可以访问action<a href="https://www.baidu.com/s?wd=%E4%B8%8A%E4%B8%8B%E6%96%87&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">上下文</a>、值栈里的对象，而过滤器不能访问。</li>
<li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器<a href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">初始化</a>时被调用一次</li>
</ol>
<p>拦截器的代码实现(以<a href="https://www.baidu.com/s?wd=struts2&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">struts2</a>为例)：<br>1、在xml文件中如何定义拦截器</p>
<interceptors><br><interceptor name="filterIPInterceptor" class="com.xxxx.web.FilterIPActionInterceptor"><br><interceptor-stack name="filterIPStack"><br><interceptor-ref name="defaultStack"><br><br><interceptor-ref name="filterIPInterceptor"><br></interceptor-ref></interceptor-ref></interceptor-stack><br></interceptor></interceptors>

<p>2、怎么遍别写自定义拦截器</p>
<p>public class FilterIPActionInterceptor extends AbstractInterceptor<br>{<br>/*<em> 日志控制. </em>/<br>private final Log log = LogFactory.getLog(getClass());</p>
<p>/**</p>
<ul>
<li>@see com.opensymphony.xwork2.interceptor.AbstractInterceptor#intercept(com.opensymphony.xwork2.ActionInvocation)<br>*/<br>@Override<br>@SuppressWarnings(“unchecked”)<br>public String intercept(ActionInvocation invocation) throws Exception<br>{<br>String result = null;<br>// 获得当前方法名.<br>String methodName = invocation.getInvocationContext().getName();<br>String currIp = null;<br>try<br>{<br>if (invocation.getAction() instanceof PortletAction)<br>{<br>PortletAction action = (PortletAction) invocation.getAction();<br>currIp = action.getRequest().getRemoteAddr();<br>}<br>String ip = ApplicationResource.getHotValue(“ALLOW_CACHE_IP”);</li>
</ul>
<p>if (StringUtils.isBlank(ip) || StringUtils.isBlank(currIp))<br>{<br>log.error(“允许刷新的IP不存在或当前请求的IP非法.”);<br>throw new NoAllowIPException();<br>}<br>else<br>{<br>String[] ips = ip.split(“,”);<br>boolean errorIp = true;<br>for (String s : ips)<br>{<br>if (s.equals(currIp))<br>errorIp = false;<br>}<br>// 判断IP<br>if (errorIp)<br>throw new NoAllowIPException();<br>}<br>result = invocation.invoke();//调用被拦截的方法<br>}<br>catch (Exception e)<br>{<br>log.error(“异常类名:” + invocation.getAction().getClass());<br>log.error(“异常方法:” + methodName, e);<br>throw e;<br>}</p>
<p>return result;<br>}</p>
<p>}</p>
<p>3、怎么编写过滤器</p>
<p>1、在web.xml里面配置自定义的拦截器</p>
<filter><br><filter-name>Redirect Filter</filter-name><br><filter-class>com.xx.filter.RedirectFilter</filter-class><br></filter>

<p><filter-mapping></filter-mapping></p>
<p><filter-name>Redirect Filter</filter-name></p>
<p><url-pattern>/xx/xx/*</url-pattern></p>
<p></p>
<p>2、如何编写自定义的拦截器<br>public class RedirectFilter implements Filter {<br>public void doFilter(ServletRequest request, ServletResponse response,<br>FilterChain filterChain) throws IOException, ServletException {<br>// 获取URL<br>Long startTime = null;<br>if (log.isDebugEnabled())<br>{<br>startTime = System.currentTimeMillis();<br>}<br>HttpServletRequest httpRequest = (HttpServletRequest) request;<br>String url = httpRequest.getRequestURL().toString();<br>if (url == null || url.trim().length() == 0) {<br>return;<br>}<br>if (url.indexOf(luceneCreateMapping) != -1<br>|| url.indexOf(luceneSearchMapping) != -1) {<br>doFilterForxxx(request, response, url);<br>} else {<br>doxxxx(request, response, url);<br>}<br>if (log.isDebugEnabled())<br>{<br>long endTime = System.currentTimeMillis();<br>Thread currentThread = Thread.currentThread();<br>String threadName = currentThread.getName();<br>log.debug(“[“ + threadName + “]” + “&lt; “</p>
<ul>
<li>this.getClass().getName() + “ “ + url + “ “</li>
<li>(endTime - startTime) + “ ms”);<br>}<br>// 激活下一个Filter<br>filterChain.doFilter(request, response);</li>
</ul>
<p>}<br>}</p>
]]></content>
      <categories>
        <category>java-初级</category>
      </categories>
      <tags>
        <tag>java,拦截器</tag>
      </tags>
  </entry>
</search>
