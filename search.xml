<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Javaa开发路线图 - 2019</title>
    <url>/2019/11/07/Java%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE-2019/</url>
    <content><![CDATA[<h3 id="1、Java-8的各项功能"><a href="#1、Java-8的各项功能" class="headerlink" title="1、Java 8的各项功能"></a>1、Java 8的各项功能</h3><p>   Java程序员应该学习并掌握的下一个重要API是Java 8的各项功能。可以毫不夸张地说，这些功能彻底改变了如今Java的编程方式。 </p>
<p>   因此，作为一名Java开发人员，您不应该错过了解与使用<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247490334&amp;idx=1&amp;sn=45e3daa153a744ada788d2f4de199192&amp;chksm=eb539e28dc24173e66d7fc010ac5c7d4fc6e69cbcc722ecc07df25b3344d63852c0e367f3904&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Lambda</a>表达式、Stream API、<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484481&amp;idx=1&amp;sn=b4a0586ce8c9a798d26a3eb6273ffa5d&amp;chksm=eb538177dc2408613493aa78273683c007427be4b217b41dc8d8b5e36435c398ce937f1af799&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Optional</a>类、以及全新Date and Time API的机会。 </p>
<p>  Java 8已经发布5年多了，如今大多数库都已停止了支持低于Java 8的版本。因此如果您想顺利地实现Java应用程序的编写与调试的话，请赶快抓紧时间学习Java 8的各项新功能。</p>
<p>关注微信公众号：Java技术栈，在后台回复：Java，可以获取我整理的 N 篇最新 Java 8－12 新特性教程，都是干货。</p>
<p><img src="/2019/11/07/Java开发路线图-2019/1.png" alt></p>
<h3 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h3><p>   测试，尤其是单元测试、集成测试和自动化测试，是任何Java开发人员必修的一项基本技能。其中，JUnit和Mockito是两种被Java开发人员最为熟悉、且欢迎的单元测试和模拟库。</p>
<p>   当然，您也可以去学习一下更高级的程序库，例如：用于业务驱动测试的Cucumber，用于集成测试的Robot Framework，以及您肯定“绕不开”的JUnit。 </p>
<p>   在常见的PowerMock、Mockito和EasyMock三种模拟库中，我强烈建议您学习Mockito。由于目前有许多Java开发人员和公司都在使用它，因此它已逐渐成为了在Java中创建模拟对象的标准库。 </p>
<h3 id="3、实用程序库"><a href="#3、实用程序库" class="headerlink" title="3、实用程序库"></a>3、实用程序库</h3><p>   一直以来，Java都拥有着丰富的开源程序库，它们可以帮助开发人员实现从日志记录到机器学习，从发送HTTP请求到解析JSON等，几乎所有的工作。 </p>
<p>   值得一提的是：Apache Commons和Google Guava这两个实用程序库，它们是Java JDK库的有效补充。 </p>
]]></content>
      <categories>
        <category>待学习</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot - 1</title>
    <url>/2019/11/05/spring-boot-1/</url>
    <content><![CDATA[<p><img src="/2019/11/05/spring-boot-1/1.png" alt></p>
<h3 id="Spring-Boot-的背景"><a href="#Spring-Boot-的背景" class="headerlink" title="Spring  Boot 的背景"></a>Spring  Boot 的背景</h3><p>  得益于Spring框架的流行，它的两把利器：IOC 和 AOP，IOC帮助我们管理对象的依赖关系，极大减少对象的耦合性，而AOP的切面编程可以方便使用动态代理来实现各种动态方法功能（如事务、缓存、日志等）。</p>
<p>  而要集成Spring框架，必须要用到XML配置文件，或者注解式的 Java 代码配置。无论使用XML或者代码配置方式，都需要对相关组件的配置有足够的了解，然后在编写大量冗长的配置代码。</p>
<h1 id="什么是Spring-Boot？"><a href="#什么是Spring-Boot？" class="headerlink" title="什么是Spring  Boot？"></a>什么是Spring  Boot？</h1><p>​    Spring boot是spring开源组织的子项目，是Srping组件一站式解决方案，简化了Spring的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>
<p>​    Spring Boot不但能创建传统的 war 包，还能创建独立的不依赖于任何外部容器（如：Tomcat）的独立应用，使用java -jar 命令就能启动。</p>
<h3 id="Spring-Boot的优点"><a href="#Spring-Boot的优点" class="headerlink" title="Spring  Boot的优点"></a>Spring  Boot的优点</h3><ul>
<li><p>独立运行</p>
<p>Spring boot内嵌各种servlet容器，Tomcat、Jetty等，现在不再需要打包成war包部署到容器中，Spring boot只要只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。</p>
</li>
<li><p>简化配置</p>
<p>spring-boot-starter-web启动器自动依赖其他组件，简化了maven配置。</p>
<p>使用Maven命令：mvn dependency：tree 也可以看到完整的依赖树：<img src="/2019/11/05/spring-boot-1/2.png" alt></p>
</li>
<li><p>自动配置</p>
</li>
</ul>
<p>​           spring boot能根据当前类路径下的类、jar包来自动bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。  </p>
<ul>
<li><p>无代码生成和XML配置</p>
<p>spring boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是spring4.x的核心功能之一。</p>
</li>
<li><p>应用监控</p>
<p>spring boot提供一系列端点可以监控服务及应用，做健康检测。</p>
</li>
</ul>
<h3 id="Spring-Boot的缺点"><a href="#Spring-Boot的缺点" class="headerlink" title="Spring Boot的缺点"></a>Spring Boot的缺点</h3><p>  1、Spring boot虽然上手很容易，但需要了解核心技术和流程，所以一旦遇到问题就很棘手，因为什么东西都集成了，自动配置化。这样需要对配置信息非常熟悉，找起问题来不是很容易。</p>
<p>  2、原始 Spring 项目很难平滑迁移到Spring boot 框架上，因为有些老旧的XML配置无法通过Java来配置，还需要额外的XML文件就不是很完美。还有，之前独立的Tomcat什么参数都在线上配置好了，改为内置的Tomcat就会遇到很多问题。</p>
<h1 id="Spring-Boot的四大核心特性"><a href="#Spring-Boot的四大核心特性" class="headerlink" title="Spring  Boot的四大核心特性"></a>Spring  Boot的四大核心特性</h1><p>  spring boot最重要的四大核心特性是 自动配置、起步依赖、Actuator、命令行界面(CLI)。其中CLI是Spring boot 的可选特性，虽然它功能强大，但也引入一套不太常规的开发模型，因此不做详解。</p>
<h3 id="一、抛砖引玉：Spring-IOC容器"><a href="#一、抛砖引玉：Spring-IOC容器" class="headerlink" title="一、抛砖引玉：Spring IOC容器"></a>一、抛砖引玉：Spring IOC容器</h3><p>  SpringApplication 启动类是对一个典型的Spring应用的启动流程进行了扩展，因此，彻底理解Spring容器是打开Spring Boot大门的一把钥匙。</p>
<h3 id="1-1、Spring-IOC容器"><a href="#1-1、Spring-IOC容器" class="headerlink" title="1.1、Spring IOC容器"></a>1.1、Spring IOC容器</h3><p>​    把spring ioc容器比作一间餐馆，当你来到餐馆，通常会直接招呼服务员：点菜！至于菜的原料是什么？如何用原料把菜做出来？who care。ioc 容器也是一样的，你告诉他需要哪个bean，他就把相应的实例（instance）扔给你，至于这个bean是否依赖其他组件，怎么完成初始化，根本不需要你的关心。</p>
<p>  作为餐馆，想要做出菜肴，得知道菜的原料和菜谱，同样的，IOC容器想要管理各个业务对象以及它们之间的依赖关系，需要通过某种途径来记录和管理这些信息。 BeanDefinition 对象就承担了这个责任：容器中的每一个bean都会有一个对应的BeanDefinition实例，该实例负责保存bean对象的所有必要信息，包括bena对象的class类型、是否是抽象类、构造方法和参数、其他属性等。当客户端向容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的bean实例。</p>
<p>  原材料已经准备好（把BeanDefinition看成原料），开始做菜吧，等等，你还需要一份菜谱，而BeanDefinitionRegistry 和 BeanFactory就是这本菜谱，BeanDefinitionRegistry 抽象出bean的注册逻辑，而BeanFactory则抽象出了bean的管理逻辑，而各个BeanFactory的实现类就具体承担了bean的注册以及管理工作。他们之间的关系如下图：<img src="/2019/11/05/spring-boot-1/3.jpg" alt></p>
<p>  DefaultListableBeanFactory作为一个比较通用的BenaFactory实现、它同时也实现了BeanDefinitionRegistry接口，因此它就承担了Bean的注册管理工作。从图中也可以看出，BeanFactory接口中主要包括getBean、containBean、getType、getAliases等管理bean的方法，而BeanDefinitionRegistry接口则包括registerBeanDefinition、removeBeanDefinition、getBeanDedinition等注册管理BeanDefinition的方法。</p>
<p>  下面通过一段简单的代码来模拟BeanFactory底层是如何工作的：<img src="/2019/11/05/spring-boot-1/4.png" alt></p>
<p>  这段代码仅为说明BeanFactory底层的大致工作流程，实际会更复杂，比如bean之间的依赖关系可能定义在外部配置文件（XML/Properties）中、也可能是注解方式。Spring Ioc容器的整个工作流程大致可以分为两个阶段：</p>
<blockquote>
<p>1.容器启动阶段</p>
</blockquote>
<p>  容器启动时，会通过某种途径加载ConfigurationMetaData。除了代码方式比较直接外，在大部分情况下，容器需要依赖某些工具类，比如BeanDefinitionReader，BeanDefinitionReader会对加载的ConfigurationMetaData进行解析和分析，并将分析后的信息组装为相应的BeanDefinition，最后把这些保存了bean定义的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器的启动工作就完成了。这个阶段主要完成一些准备性工作，更侧重于bean对象管理信息的收集，当然一些验证性或辅助性的工作也在这一阶段完成。</p>
<p>看一个简单例子，以前，所有的bean都定义在XML配置文件中，下面的代码将模拟BeanFactory如何从配置文件中加载bean的定义以及依赖关系：<img src="/2019/11/05/spring-boot-1/5.png" alt></p>
<blockquote>
<p>2.Bean的实例化阶段</p>
</blockquote>
<p>  经过第一个阶段，所有bean定义都通过BeanDefinition的方式注册到BeanDefinitionRegistry中，当某个请求通过容器的getBean方法请求某个对象，或者因为依赖关系容器需要隐式的调用getBean时，就会触发第二阶段的活动，容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完成后，容器会立刻将其返回给请求方法使用。</p>
<p>  BeanFactory只是Spring Ioc容器的一种实现，如果没有特殊指定，它采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。而在实际场景下，我们更多的使用另外一种类型的容器：ApplicationContext，它构建在BeanFactory之上，属于更高级的容器，除了具有BeanFactory的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的bean，在容器启动时全部完成初始化和依赖注入操作。</p>
<h3 id="1-2、Spring容器扩展机制"><a href="#1-2、Spring容器扩展机制" class="headerlink" title="1.2、Spring容器扩展机制"></a>1.2、Spring容器扩展机制</h3><p>  IoC容器负责管理容器中所有bean的生命周期，而在bean生命周期的不同阶段，Spring提供了不同的扩展点来改变bean的命运。在容器的启动阶段，BeanFactoryPostProcessor允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做一些额外的操作，比如修改bean定义的某些属性或者增加其它信息等。</p>
<p>  如果要自定义扩展类，通常需要实现 org.springframework.beans.factory.config.BeanFactoryPostProcessor接口，与此同时，因为容器中可能有多个BeanFactoryPostProcessor，可能还需要实现 org.springframework.core.Ordered接口，以保证BeanFactoryPostProcessor按照顺序执行。Spring 提供了为数不多的BeanFactoryPostProcessor实现，我们以PropertryPlaceholderConfigurer来说明大致工作流程。</p>
<p>  在Spring项目的XML配置文件中，经常可以看到许多配置项的值使用占位符，而将占位符所代表的值单独配置到独立的 properties 文件中，这样可以将散落在不同XML文件中的配置集中管理，而且也方便运维根据不同的环境进行匹配不同的值。这个非常实用的功能就是由 PropertyPlaceholderConfigurer负责实现的。</p>
<p>  根据前文，当BeanFactory在第一阶段加载完所有配置信息时，BeanFactory中保存的对象的属性还是以占位符方式存在的，比如 ${jdbc.mysql.url}。当 PropertyPlaceholderConfigurer 作为BeanFactoryProcessor被应用时，它会使用properties配置文件中的值来替换相应的BeanDefinition中占位符所表示的属性值。当需要实例化bean时，bean定义中的属性值就已经被替换我们配置的值。当然其实现比上面描述的要复杂一些，这里仅说明其大致工作原理，更详细的实现可以参考源码。</p>
<p>  与之相似的，还有BeanPostProcessor，其存在于对象实例化阶段。跟BeanFactoryPostProcessor类似，它会处理容器内所有符合条件并且已经实例化后的对象。简单的对比，BeanFactoryPostProcessor处理bean的定义，而BeanPostProcessor则处理bean完成实例化后的对象。BeanPostProcessor定义了两个接口：<img src="/2019/11/05/spring-boot-1/6.png" alt></p>
<p>  为了理解这两个方法执行的时机，简单了解bean的整个生命周期：(Bean的实例化过程)<img src="/2019/11/05/spring-boot-1/7.png" alt></p>
<p>  postProcessBeforeInitialization()方法与postProcessAfterInitialization()分别对应图中前置处理和后置处理两个步骤将执行的方法。这两个方法中都传入了bean对象实例的引用，为扩展容器的对象实例化过程提供了很大便利，在这几乎可以对传入的实例执行任何操作。注解、AOP等功能的实现均大量使用了 BeanPostProcessor，比如有一个自定义注解，你完全可以实现 BeanPostProcessor 的接口，在其中判断bean对象的脑袋上是否有该注解，如果有，你可以对这个bean实例执行任何操作，想想是不是非常简单？</p>
<p>  再来看一个更常见的例子，在Spring中经常能看到各种各样的Aware接口，其作用就是在对象实例化完成后将Aware接口中规定的依赖注入到当前实例中。比如最常见的ApplicationContextAware接口，实现了这个接口的类都可以获得一个ApplicationContext对象。当容器</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>简单认识markdown语法</title>
    <url>/2019/11/04/%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p><img src="/images/iconfinder_markdown_298823.png" alt></p>
<p>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>由约翰 格鲁伯 (john Gruber) 于2004年创建。</p>
<p>可以导出HTML、Word、图像、PDF、Epub等格式文档。</p>
<p>文档后缀 .md ，.markdown。</p>
<h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><h4 id="1、使用-和-标记一级和二级标题"><a href="#1、使用-和-标记一级和二级标题" class="headerlink" title="1、使用 = 和 - 标记一级和二级标题"></a>1、使用 = 和 - 标记一级和二级标题</h4><p>​      = 和 -标记语法格式如下：</p>
<p>​     <img src="/images/微信截图_20191104144807.png" alt></p>
<p>​      显示效果如下图：</p>
<p><img src="/images/01986C87-7E19-4497-878E-AE996AFC088E.jpg" alt></p>
<h4 id="2、使用-号标记"><a href="#2、使用-号标记" class="headerlink" title="2、使用 # 号标记"></a>2、使用 # 号标记</h4><p>​        使用#号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p>
<p><img src="/images/微信截图_20191104145328.png" alt></p>
<p>​        显示效果如下：</p>
<p><img src="/images/微信截图_20191104145441.png" alt></p>
<h1 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h1><p>Markdown 段落没有特殊的格式，直接编辑文字就好，段落的换行是使用两个以上空格加上回车。<img src="/2019/11/04/简单认识markdown语法/1.png" alt></p>
<p> 当然也可以在段落后使用一个空行来表示重新开始一个段落。<img src="/2019/11/04/简单认识markdown语法/2.png" alt></p>
<h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><p> 可以使用以下几种字体：<img src="/2019/11/04/简单认识markdown语法/3.png" alt></p>
<p>效果如下：</p>
<p><img src="/2019/11/04/简单认识markdown语法/4.png" alt></p>
<h3 id="3-分隔线"><a href="#3-分隔线" class="headerlink" title="3.分隔线"></a>3.分隔线</h3><p>   用三个以上的星号、减号、底线来表示，符号中间可以有空格。<img src="/2019/11/04/简单认识markdown语法/5.png" alt></p>
<p>   效果如下：<img src="/2019/11/04/简单认识markdown语法/6.png" alt></p>
<h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4.删除线"></a>4.删除线</h3><p>​    在文字两端加上~~即可。<img src="/2019/11/04/简单认识markdown语法/7.png" alt></p>
<p>​    效果如下：</p>
<p><img src="/2019/11/04/简单认识markdown语法/8.png" alt></p>
<h3 id="5-下划线"><a href="#5-下划线" class="headerlink" title="5.下划线"></a>5.下划线</h3><p>​      通过HTML的 <u> 标签来实现。<img src="/2019/11/04/简单认识markdown语法/9.png" alt></u></p>
<p>​      效果如下：     </p>
<p><img src="/2019/11/04/简单认识markdown语法/10.png" alt></p>
<h3 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h3><p>​         脚注是对文本的补充说明。<img src="/2019/11/04/简单认识markdown语法/11.png" alt></p>
<p>​         用法如下：</p>
<p><img src="/2019/11/04/简单认识markdown语法/12.png" alt></p>
<p>​        效果如下：</p>
<p><img src="/2019/11/04/简单认识markdown语法/13.png" alt></p>
<h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h3><p>​    使用型号 * 、加号 +、或 减号 - 作为标记。<img src="/2019/11/04/简单认识markdown语法/14.png" alt></p>
<p>​     效果如下：<img src="/2019/11/04/简单认识markdown语法/15.png" alt></p>
<h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h3><p>​     用数字加上 . 号表示：<img src="/2019/11/04/简单认识markdown语法/16.png" alt></p>
<p>​     效果如下：<img src="/2019/11/04/简单认识markdown语法/17.png" alt></p>
<h3 id="3-列表嵌套"><a href="#3-列表嵌套" class="headerlink" title="3.列表嵌套"></a>3.列表嵌套</h3><p>​      列表嵌套只需在子列表中的选项中添加四个空格即可。<img src="/2019/11/04/简单认识markdown语法/18.png" alt></p>
<p>​     效果如下：</p>
<p><img src="/2019/11/04/简单认识markdown语法/19.png" alt></p>
<h1 id="Markdown区块"><a href="#Markdown区块" class="headerlink" title="Markdown区块"></a>Markdown区块</h1><p>在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>我的尝试</title>
    <url>/2019/02/26/%E6%88%91%E7%9A%84%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<p>1、首先要明确什么是拦截器、什么是过滤器<br>1.1 什么是拦截器：<br>拦截器，在<a href="https://www.baidu.com/s?wd=AOP&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">AOP</a>（Aspect-Oriented Programming）中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。<br>在Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行。同时也是提供了一种可以提取action中可重用的部分的方式。<br>谈到拦截器，还有一个词大家应该知道——拦截器链（Interceptor Chain，在Struts 2中称为拦截器栈 Interceptor Stack）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。<br>1.2. 拦截器的实现原理：<br>大部分时候，拦截器方法都是通过代理的方式来调用的。Struts 2的拦截器实现相对简单。当请求到达Struts 2的ServletDispatcher时，Struts 2会查找配置文件，并根据其配置实例化相对的拦截器对象，然后串成一个列表（list），最后一个一个地调用列表中的拦截器。<br>1.3 什么是过滤器<br>过滤器是一个程序，它先于与之相关的servlet或<a href="https://www.baidu.com/s?wd=JSP&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">JSP</a>页面运行在服务器上。过滤器可附加到一个或多个servlet或JSP页面上，并且可以检查进入这些资源的请求信息。在这之后，过滤器可以作如下的选择：<br>①以常规的方式调用资源（即，调用servlet或JSP页面）。<br>②利用修改过的请求信息调用资源。<br>③调用资源，但在发送响应到<a href="https://www.baidu.com/s?wd=%E5%AE%A2%E6%88%B7%E6%9C%BA&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">客户机</a>前对其进行修改。<br>④阻止该资源调用，代之以转到其他的资源，返回一个特定的状态代码或生成替换输出。</p>
<p>1.4 Servlet过滤器的基本原理<br>在Servlet作为过滤器使用时，它可以对客户的请求进行处理。处理完成后，它会交给下一个过滤器处理，这样，客户的请求在过滤链里逐个处理，直到请求发送到目标为止。例如，某网站里有提交“修改的注册信息”的网页，当用户填写完修改信息并提交后，服务器在进行处理时需要做两项工作：判断客户端的会话是否有效；对提交的数据进行统一编码。这两项工作可以在由两个过滤器组成的过滤链里进行处理。当过滤器处理成功后，把提交的数据发送到最终目标；如果过滤器处理不成功，将把视图派发到指定的错误页面。</p>
<p>2、拦截器与过滤器的区别 ：</p>
<ol>
<li>拦截器是基于java的<a href="https://www.baidu.com/s?wd=%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">反射机制</a>的，而过滤器是基于<a href="https://www.baidu.com/s?wd=%E5%87%BD%E6%95%B0&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">函数</a><a href="https://www.baidu.com/s?wd=%E5%9B%9E%E8%B0%83&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">回调</a>。</li>
<li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li>
<li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li>
<li>拦截器可以访问action<a href="https://www.baidu.com/s?wd=%E4%B8%8A%E4%B8%8B%E6%96%87&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">上下文</a>、值栈里的对象，而过滤器不能访问。</li>
<li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器<a href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">初始化</a>时被调用一次</li>
</ol>
<p>拦截器的代码实现(以<a href="https://www.baidu.com/s?wd=struts2&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">struts2</a>为例)：<br>1、在xml文件中如何定义拦截器</p>
<interceptors><br><interceptor name="filterIPInterceptor" class="com.xxxx.web.FilterIPActionInterceptor"><br><interceptor-stack name="filterIPStack"><br><interceptor-ref name="defaultStack"><br><br><interceptor-ref name="filterIPInterceptor"><br></interceptor-ref></interceptor-ref></interceptor-stack><br></interceptor></interceptors>

<p>2、怎么遍别写自定义拦截器</p>
<p>public class FilterIPActionInterceptor extends AbstractInterceptor<br>{<br>/*<em> 日志控制. </em>/<br>private final Log log = LogFactory.getLog(getClass());</p>
<p>/**</p>
<ul>
<li>@see com.opensymphony.xwork2.interceptor.AbstractInterceptor#intercept(com.opensymphony.xwork2.ActionInvocation)<br>*/<br>@Override<br>@SuppressWarnings(“unchecked”)<br>public String intercept(ActionInvocation invocation) throws Exception<br>{<br>String result = null;<br>// 获得当前方法名.<br>String methodName = invocation.getInvocationContext().getName();<br>String currIp = null;<br>try<br>{<br>if (invocation.getAction() instanceof PortletAction)<br>{<br>PortletAction action = (PortletAction) invocation.getAction();<br>currIp = action.getRequest().getRemoteAddr();<br>}<br>String ip = ApplicationResource.getHotValue(“ALLOW_CACHE_IP”);</li>
</ul>
<p>if (StringUtils.isBlank(ip) || StringUtils.isBlank(currIp))<br>{<br>log.error(“允许刷新的IP不存在或当前请求的IP非法.”);<br>throw new NoAllowIPException();<br>}<br>else<br>{<br>String[] ips = ip.split(“,”);<br>boolean errorIp = true;<br>for (String s : ips)<br>{<br>if (s.equals(currIp))<br>errorIp = false;<br>}<br>// 判断IP<br>if (errorIp)<br>throw new NoAllowIPException();<br>}<br>result = invocation.invoke();//调用被拦截的方法<br>}<br>catch (Exception e)<br>{<br>log.error(“异常类名:” + invocation.getAction().getClass());<br>log.error(“异常方法:” + methodName, e);<br>throw e;<br>}</p>
<p>return result;<br>}</p>
<p>}</p>
<p>3、怎么编写过滤器</p>
<p>1、在web.xml里面配置自定义的拦截器</p>
<filter><br><filter-name>Redirect Filter</filter-name><br><filter-class>com.xx.filter.RedirectFilter</filter-class><br></filter>

<p><filter-mapping></filter-mapping></p>
<p><filter-name>Redirect Filter</filter-name></p>
<p><url-pattern>/xx/xx/*</url-pattern></p>
<p></p>
<p>2、如何编写自定义的拦截器<br>public class RedirectFilter implements Filter {<br>public void doFilter(ServletRequest request, ServletResponse response,<br>FilterChain filterChain) throws IOException, ServletException {<br>// 获取URL<br>Long startTime = null;<br>if (log.isDebugEnabled())<br>{<br>startTime = System.currentTimeMillis();<br>}<br>HttpServletRequest httpRequest = (HttpServletRequest) request;<br>String url = httpRequest.getRequestURL().toString();<br>if (url == null || url.trim().length() == 0) {<br>return;<br>}<br>if (url.indexOf(luceneCreateMapping) != -1<br>|| url.indexOf(luceneSearchMapping) != -1) {<br>doFilterForxxx(request, response, url);<br>} else {<br>doxxxx(request, response, url);<br>}<br>if (log.isDebugEnabled())<br>{<br>long endTime = System.currentTimeMillis();<br>Thread currentThread = Thread.currentThread();<br>String threadName = currentThread.getName();<br>log.debug(“[“ + threadName + “]” + “&lt; “</p>
<ul>
<li>this.getClass().getName() + “ “ + url + “ “</li>
<li>(endTime - startTime) + “ ms”);<br>}<br>// 激活下一个Filter<br>filterChain.doFilter(request, response);</li>
</ul>
<p>}<br>}</p>
]]></content>
      <categories>
        <category>java-基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
